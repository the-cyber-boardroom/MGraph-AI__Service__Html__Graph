# LLM Implementation Brief: Export Service Architecture Refactoring

**Version**: v1.3.2  
**Date**: December 22, 2025  
**Status**: Ready for Implementation  
**Predecessor**: v1.3.0 Multi-Graph Implementation (completed)

---

## 1. Executive Summary

This brief describes the architectural refactoring of `Html_Graph__Export__Service` and related components to achieve clean separation of concerns between:

1. **HTML Parsing** → Html_MGraph creation
2. **Graph Selection/Assembly** → Single MGraph for rendering
3. **Graph Transformation** → Node/edge filtering and styling
4. **Engine Rendering** → Format-specific output generation

The refactoring introduces dedicated engine classes (`MGraph__Engine__*`) with typed configurations and per-engine callbacks in transformations, enabling transformations to control visualization without embedding engine-specific code in the export service.

### Key Deliverables

| Component | Action | Location |
|-----------|--------|----------|
| `MGraph__Engine__Base` | New | `service/mgraph__engines/` |
| `MGraph__Engine__Dot` | New | `service/mgraph__engines/` |
| `MGraph__Engine__D3` | New | `service/mgraph__engines/` |
| `MGraph__Engine__Cytoscape` | New | `service/mgraph__engines/` |
| `MGraph__Engine__VisJs` | New | `service/mgraph__engines/` |
| `MGraph__Engine__Mermaid` | New | `service/mgraph__engines/` |
| `MGraph__Engine__Tree` | New | `service/mgraph__engines/` |
| `Graph_Transformation__Base` | Refactor | `service/html_graph__transformations/` |
| All 6 transformations | Refactor | `service/html_graph__transformations/` |
| `Graph_Transform__Full_Document` | New | `service/html_graph__transformations/` |
| `Html_Graph__Export__Service` | Refactor | `service/html_graph__export/` |

---

## 2. Problem Statement

### 2.1 Current Architecture Issues

The current `Html_Graph__Export__Service` mixes multiple concerns:

```python
# CURRENT: Everything mixed in one method
def to_visjs(self, request, transformation="default") -> dict:
    config      = self.create_config(request)                    # Config creation
    html_mgraph = self.html_to_mgraph_with_transformation(...)   # Parsing + transform
    exporter    = Html_MGraph__To__VisJs(html_mgraph=..., config=config)  # Engine
    data        = exporter.export()                              # Export
    stats       = self.get_stats(html_mgraph)                    # Stats
    result      = { 'nodes': ..., 'edges': ... }                 # Format
    return self.apply_export_transformation(result, transformation)  # Post-process
```

**Problems identified:**

1. **Wrong return type in transformations**: `transform_mgraph(Html_MGraph) → Html_MGraph` but engines need `MGraph`

2. **Transformation doesn't control parsing**: The service calls `Html_MGraph.from_html()` outside the transformation, limiting customization

3. **Engine code scattered**: Each `Html_MGraph__To__*` class has engine-specific logic duplicated, not reusable

4. **No transformation influence on engine config**: Transformations can only post-process export data, cannot set `rankdir`, `splines`, colors at engine level

5. **Styling metadata unclear**: `Html_MGraph__Data__Extractor` adds colors/labels but it's unclear when this happens in the pipeline

### 2.2 Current Transformation Pipeline

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    CURRENT PIPELINE (3 Phases)                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Phase 1: transform_html(html) → html                                       │
│           ↓                                                                  │
│           [Service calls Html_MGraph.from_html(html)]  ← Outside transform  │
│           ↓                                                                  │
│  Phase 2: transform_mgraph(Html_MGraph) → Html_MGraph  ← Wrong return type  │
│           ↓                                                                  │
│           [Service selects which graph, creates exporter]                   │
│           ↓                                                                  │
│  Phase 3: transform_export(dict) → dict                ← Too late to affect │
│                                                           engine config     │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 3. Solution Architecture

### 3.1 New 4-Phase Pipeline

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    NEW PIPELINE (4 Phases)                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  PHASE 1: html__to__html_mgraph(html) → Html_MGraph                         │
│  ─────────────────────────────────────────────────────                      │
│  • Transformation owns parsing completely                                   │
│  • Base: return Html_MGraph.from_html(html)                                 │
│  • Override: custom parsing, pre-processing, etc.                           │
│                                                                              │
│  PHASE 2: html_mgraph__to__mgraph(Html_MGraph) → MGraph                     │
│  ───────────────────────────────────────────────────────                    │
│  • Transformation selects/assembles the graph to render                     │
│  • Base: return html_mgraph.body_graph.mgraph                               │
│  • Override: head_graph, attrs_graph, combined, custom                      │
│                                                                              │
│  PHASE 3: transform_mgraph(MGraph) → MGraph                                 │
│  ─────────────────────────────────────────────                              │
│  • Filters, styling, node/edge modifications                                │
│  • Base: return mgraph (no-op)                                              │
│  • Override: add colors, remove nodes, merge, etc.                          │
│                                                                              │
│  PHASE 4: Engine renders MGraph → Output                                    │
│  ───────────────────────────────────────────                                │
│  • Engine class converts MGraph to format                                   │
│  • Transformation configures via callbacks:                                 │
│    - configure_dot(config)                                                  │
│    - configure_d3(config)                                                   │
│    - configure_cytoscape(config)                                            │
│    - etc.                                                                   │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 Data Flow Diagram

```
                    ┌─────────────────────────────────────────────────────┐
                    │              Html_Graph__Export__Service             │
                    └─────────────────────────────────────────────────────┘
                                           │
                                           │ to_dot(html, transformation)
                                           ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                                                                              │
│   html: str ──────────────────────────────────────────────────────────────► │
│         │                                                                    │
│         │  Phase 1                                                          │
│         ▼                                                                    │
│   ┌─────────────────────────────────────────────────────────┐               │
│   │  transformation.html__to__html_mgraph(html)             │               │
│   │  ─────────────────────────────────────────────────────  │               │
│   │  Base: Html_MGraph.from_html(html)                      │               │
│   └─────────────────────────────────────────────────────────┘               │
│         │                                                                    │
│         │  Html_MGraph                                                      │
│         ▼                                                                    │
│   ┌─────────────────────────────────────────────────────────┐               │
│   │  transformation.html_mgraph__to__mgraph(html_mgraph)    │               │
│   │  ─────────────────────────────────────────────────────  │               │
│   │  Base: html_mgraph.body_graph.mgraph                    │               │
│   └─────────────────────────────────────────────────────────┘               │
│         │                                                                    │
│         │  MGraph (raw nodes + edges)                                       │
│         ▼                                                                    │
│   ┌─────────────────────────────────────────────────────────┐               │
│   │  transformation.transform_mgraph(mgraph)                │               │
│   │  ─────────────────────────────────────────────────────  │               │
│   │  Base: return mgraph (no-op)                            │               │
│   │  Override: add styling metadata to nodes                │               │
│   └─────────────────────────────────────────────────────────┘               │
│         │                                                                    │
│         │  MGraph (styled nodes + edges)                                    │
│         ▼                                                                    │
│   ┌─────────────────────────────────────────────────────────┐               │
│   │  engine = MGraph__Engine__Dot(mgraph)                   │               │
│   │  transformation.configure_dot(engine.config)            │               │
│   │  output = engine.export()                               │               │
│   └─────────────────────────────────────────────────────────┘               │
│         │                                                                    │
│         │  str (DOT code) or dict (D3/Cytoscape/VisJs)                     │
│         ▼                                                                    │
│   ┌─────────────────────────────────────────────────────────┐               │
│   │  transformation.transform_export(output)                │               │
│   │  ─────────────────────────────────────────────────────  │               │
│   │  Base: return output (no-op)                            │               │
│   │  Override: post-process format-specific adjustments     │               │
│   └─────────────────────────────────────────────────────────┘               │
│         │                                                                    │
│         ▼                                                                    │
│   return output ◄──────────────────────────────────────────────────────────│
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 4. Detailed Contracts

### 4.1 Graph_Transformation__Base (Refactored)

**Location**: `service/html_graph__transformations/Graph_Transformation__Base.py`

```python
from typing                                                       import Dict, Any
from mgraph_ai_service_html_graph.service.html_mgraph.Html_MGraph import Html_MGraph
from mgraph_db.mgraph.MGraph                                      import MGraph
from osbot_utils.type_safe.Type_Safe                              import Type_Safe

# Forward declarations for engine configs (avoid circular imports)
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from mgraph_ai_service_html_graph.service.mgraph__engines.configs.MGraph__Engine__Config__Dot       import MGraph__Engine__Config__Dot
    from mgraph_ai_service_html_graph.service.mgraph__engines.configs.MGraph__Engine__Config__D3        import MGraph__Engine__Config__D3
    from mgraph_ai_service_html_graph.service.mgraph__engines.configs.MGraph__Engine__Config__Cytoscape import MGraph__Engine__Config__Cytoscape
    from mgraph_ai_service_html_graph.service.mgraph__engines.configs.MGraph__Engine__Config__VisJs     import MGraph__Engine__Config__VisJs
    from mgraph_ai_service_html_graph.service.mgraph__engines.configs.MGraph__Engine__Config__Mermaid   import MGraph__Engine__Config__Mermaid
    from mgraph_ai_service_html_graph.service.mgraph__engines.configs.MGraph__Engine__Config__Tree      import MGraph__Engine__Config__Tree


class Graph_Transformation__Base(Type_Safe):
    """Base class for all graph transformations.
    
    Pipeline:
        Phase 1: html__to__html_mgraph(html) → Html_MGraph
        Phase 2: html_mgraph__to__mgraph(html_mgraph) → MGraph  
        Phase 3: transform_mgraph(mgraph) → MGraph
        Phase 4: configure_<engine>(config) callbacks
        Phase 5: transform_export(output) → output
    """

    name        : str = "default"
    label       : str = "Default"
    description : str = "Standard body graph visualization"

    # ═══════════════════════════════════════════════════════════════════════════
    # Phase 1: HTML → Html_MGraph
    # ═══════════════════════════════════════════════════════════════════════════

    def html__to__html_mgraph(self, html: str) -> Html_MGraph:
        """Convert HTML string to Html_MGraph.
        
        Override to:
        - Pre-process HTML before parsing
        - Use custom parsing logic
        - Inject elements or modify structure
        
        Default: Uses Html_MGraph.from_html()
        """
        return Html_MGraph.from_html(html)

    # ═══════════════════════════════════════════════════════════════════════════
    # Phase 2: Html_MGraph → MGraph
    # ═══════════════════════════════════════════════════════════════════════════

    def html_mgraph__to__mgraph(self, html_mgraph: Html_MGraph) -> MGraph:
        """Select or assemble the MGraph to render.
        
        Override to:
        - Select different subgraph (head, attrs, scripts, styles)
        - Combine multiple subgraphs into one
        - Create entirely new graph structure
        
        Default: Returns body_graph.mgraph
        """
        if html_mgraph.body_graph and html_mgraph.body_graph.mgraph:
            return html_mgraph.body_graph.mgraph
        return MGraph()  # Empty graph if no body

    # ═══════════════════════════════════════════════════════════════════════════
    # Phase 3: MGraph → MGraph (filtering, styling)
    # ═══════════════════════════════════════════════════════════════════════════

    def transform_mgraph(self, mgraph: MGraph) -> MGraph:
        """Transform the MGraph before rendering.
        
        Override to:
        - Filter nodes/edges
        - Add styling metadata (colors, labels)
        - Collapse or merge nodes
        - Add computed properties
        
        Default: Returns mgraph unchanged
        """
        return mgraph

    # ═══════════════════════════════════════════════════════════════════════════
    # Phase 4: Engine Configuration Callbacks
    # ═══════════════════════════════════════════════════════════════════════════

    def configure_dot(self, config: 'MGraph__Engine__Config__Dot') -> None:
        """Configure DOT/Graphviz engine settings.
        
        Override to set: rankdir, splines, node_sep, rank_sep, 
        node shapes, edge styles, colors, fonts, etc.
        """
        pass  # Default: use engine defaults

    def configure_d3(self, config: 'MGraph__Engine__Config__D3') -> None:
        """Configure D3.js force-directed engine settings.
        
        Override to set: charge_strength, link_distance, 
        collision_radius, center_strength, etc.
        """
        pass

    def configure_cytoscape(self, config: 'MGraph__Engine__Config__Cytoscape') -> None:
        """Configure Cytoscape.js engine settings.
        
        Override to set: layout algorithm, spacing, 
        animation, fit options, etc.
        """
        pass

    def configure_visjs(self, config: 'MGraph__Engine__Config__VisJs') -> None:
        """Configure vis.js Network engine settings.
        
        Override to set: physics, layout, interaction,
        node/edge defaults, etc.
        """
        pass

    def configure_mermaid(self, config: 'MGraph__Engine__Config__Mermaid') -> None:
        """Configure Mermaid engine settings.
        
        Override to set: direction, theme, node styles, etc.
        """
        pass

    def configure_tree(self, config: 'MGraph__Engine__Config__Tree') -> None:
        """Configure Tree view engine settings.
        
        Override to set: indentation, format, max_depth, etc.
        """
        pass

    # ═══════════════════════════════════════════════════════════════════════════
    # Phase 5: Export Post-Processing
    # ═══════════════════════════════════════════════════════════════════════════

    def transform_export(self, export_data: Any) -> Any:
        """Post-process the engine output.
        
        Override to:
        - Filter output fields
        - Add custom metadata
        - Format-specific adjustments
        
        Default: Returns export_data unchanged
        
        Note: export_data type depends on engine:
        - DOT/Mermaid: str
        - D3/Cytoscape/VisJs: dict
        - Tree: dict or str
        """
        return export_data

    # ═══════════════════════════════════════════════════════════════════════════
    # Metadata
    # ═══════════════════════════════════════════════════════════════════════════

    def to_dict(self) -> Dict[str, str]:
        """Return transformation metadata for API."""
        return dict(name        = self.name       ,
                    label       = self.label      ,
                    description = self.description)
```

### 4.2 Engine Base Class

**Location**: `service/mgraph__engines/MGraph__Engine__Base.py`

```python
from typing                          import Any, Dict, List, Optional, TypeVar, Generic
from mgraph_db.mgraph.MGraph         import MGraph
from osbot_utils.type_safe.Type_Safe import Type_Safe

T = TypeVar('T', bound='MGraph__Engine__Config__Base')


class MGraph__Engine__Config__Base(Type_Safe):
    """Base configuration for all engines."""
    pass


class MGraph__Engine__Base(Type_Safe, Generic[T]):
    """Base class for all MGraph rendering engines.
    
    Responsibilities:
    - Hold MGraph to render
    - Hold typed configuration
    - Provide export() method returning engine-specific format
    - Provide hooks for node/edge customization
    """
    
    mgraph : MGraph = None
    config : T      = None

    def export(self) -> Any:
        """Export MGraph to engine-specific format.
        
        Returns:
        - str for DOT, Mermaid
        - dict for D3, Cytoscape, VisJs, Tree
        """
        raise NotImplementedError("Subclasses must implement export()")

    # ═══════════════════════════════════════════════════════════════════════════
    # Node/Edge Iteration Helpers
    # ═══════════════════════════════════════════════════════════════════════════

    def nodes(self) -> List:
        """Get all nodes from MGraph."""
        if self.mgraph and self.mgraph.data():
            return list(self.mgraph.data().nodes())
        return []

    def edges(self) -> List:
        """Get all edges from MGraph."""
        if self.mgraph and self.mgraph.data():
            return list(self.mgraph.data().edges())
        return []

    def node_ids(self) -> List:
        """Get all node IDs."""
        if self.mgraph and self.mgraph.data():
            return list(self.mgraph.data().nodes_ids())
        return []

    def edge_ids(self) -> List:
        """Get all edge IDs."""
        if self.mgraph and self.mgraph.data():
            return list(self.mgraph.data().edges_ids())
        return []

    # ═══════════════════════════════════════════════════════════════════════════
    # Node Data Access Helpers
    # ═══════════════════════════════════════════════════════════════════════════

    def node_path(self, node) -> Optional[str]:
        """Get node_path from node."""
        if hasattr(node, 'node') and hasattr(node.node, 'data'):
            path = node.node.data.node_path
            return str(path) if path else None
        return None

    def node_value(self, node) -> Optional[str]:
        """Get value from value node."""
        if hasattr(node, 'node') and hasattr(node.node, 'data'):
            node_data = node.node.data
            if hasattr(node_data, 'node_data') and hasattr(node_data.node_data, 'value'):
                return str(node_data.node_data.value)
        return None

    def node_id_str(self, node) -> str:
        """Get node ID as string."""
        if hasattr(node, 'node_id'):
            return str(node.node_id)
        return str(id(node))

    # ═══════════════════════════════════════════════════════════════════════════
    # Edge Data Access Helpers
    # ═══════════════════════════════════════════════════════════════════════════

    def edge_from_id(self, edge) -> str:
        """Get source node ID from edge."""
        if hasattr(edge, 'edge') and hasattr(edge.edge, 'data'):
            return str(edge.edge.data.from_node_id)
        return ''

    def edge_to_id(self, edge) -> str:
        """Get target node ID from edge."""
        if hasattr(edge, 'edge') and hasattr(edge.edge, 'data'):
            return str(edge.edge.data.to_node_id)
        return ''

    def edge_predicate(self, edge) -> Optional[str]:
        """Get predicate from edge label."""
        if hasattr(edge, 'edge') and hasattr(edge.edge, 'data'):
            label = edge.edge.data.edge_label
            if label and hasattr(label, 'predicate') and label.predicate:
                return str(label.predicate)
        return None

    def edge_path(self, edge) -> Optional[str]:
        """Get edge_path from edge."""
        if hasattr(edge, 'edge') and hasattr(edge.edge, 'data'):
            path = edge.edge.data.edge_path
            return str(path) if path else None
        return None

    # ═══════════════════════════════════════════════════════════════════════════
    # Styling Metadata Access (from node attributes)
    # ═══════════════════════════════════════════════════════════════════════════

    def get_node_style(self, node, key: str, default: Any = None) -> Any:
        """Get styling metadata from node.
        
        Transformations add styling via node attributes.
        Convention: style keys prefixed with 'style_'
        """
        # Implementation depends on how we store metadata
        # Could be in node_data.metadata dict or similar
        return default  # Placeholder

    def get_edge_style(self, edge, key: str, default: Any = None) -> Any:
        """Get styling metadata from edge."""
        return default  # Placeholder
```

### 4.3 DOT Engine

**Location**: `service/mgraph__engines/MGraph__Engine__Dot.py`

```python
from typing                                                                            import List, Dict, Any, Optional
from mgraph_ai_service_html_graph.service.mgraph__engines.MGraph__Engine__Base         import MGraph__Engine__Base, MGraph__Engine__Config__Base
from osbot_utils.type_safe.Type_Safe                                                   import Type_Safe


class MGraph__Engine__Config__Dot(MGraph__Engine__Config__Base):
    """Configuration for DOT/Graphviz engine."""
    
    # Graph settings
    rankdir       : str   = 'TB'          # TB, BT, LR, RL
    splines       : str   = 'ortho'       # ortho, polyline, curved, line, none
    node_sep      : float = 0.5           # Horizontal separation
    rank_sep      : float = 0.75          # Vertical separation
    bgcolor       : str   = ''            # Background color
    
    # Default node settings
    node_shape    : str   = 'box'         # box, ellipse, circle, diamond, etc.
    node_style    : str   = 'filled,rounded'
    node_fontname : str   = 'Arial'
    node_fontsize : int   = 10
    node_fillcolor: str   = '#E8E8E8'
    node_fontcolor: str   = '#333333'
    
    # Default edge settings
    edge_fontname : str   = 'Arial'
    edge_fontsize : int   = 8
    edge_color    : str   = '#666666'
    edge_arrowsize: float = 0.5
    
    # Label settings
    show_node_path : bool = True
    show_node_value: bool = True
    show_edge_label: bool = True
    max_label_length: int = 30


class MGraph__Engine__Dot(MGraph__Engine__Base[MGraph__Engine__Config__Dot]):
    """DOT/Graphviz rendering engine.
    
    Converts MGraph to DOT format string for Graphviz rendering.
    """
    
    config: MGraph__Engine__Config__Dot = None

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        if self.config is None:
            self.config = MGraph__Engine__Config__Dot()

    def export(self) -> str:
        """Export MGraph to DOT format string."""
        lines = []
        
        lines.append('digraph MGraph {')
        lines.extend(self._graph_attributes())
        lines.extend(self._default_node_attributes())
        lines.extend(self._default_edge_attributes())
        lines.append('')
        
        for node in self.nodes():
            lines.append(self._format_node(node))
        
        lines.append('')
        
        for edge in self.edges():
            lines.append(self._format_edge(edge))
        
        lines.append('}')
        
        return '\n'.join(lines)

    def _graph_attributes(self) -> List[str]:
        """Generate graph-level DOT attributes."""
        attrs = []
        attrs.append(f'    rankdir={self.config.rankdir};')
        attrs.append(f'    splines={self.config.splines};')
        attrs.append(f'    nodesep={self.config.node_sep};')
        attrs.append(f'    ranksep={self.config.rank_sep};')
        if self.config.bgcolor:
            attrs.append(f'    bgcolor="{self.config.bgcolor}";')
        return attrs

    def _default_node_attributes(self) -> List[str]:
        """Generate default node attributes."""
        return [
            f'    node [shape={self.config.node_shape}, '
            f'style="{self.config.node_style}", '
            f'fontname="{self.config.node_fontname}", '
            f'fontsize={self.config.node_fontsize}];'
        ]

    def _default_edge_attributes(self) -> List[str]:
        """Generate default edge attributes."""
        return [
            f'    edge [fontname="{self.config.edge_fontname}", '
            f'fontsize={self.config.edge_fontsize}, '
            f'arrowsize={self.config.edge_arrowsize}];'
        ]

    def _format_node(self, node) -> str:
        """Format a single node as DOT."""
        node_id = self._safe_id(self.node_id_str(node))
        label   = self._node_label(node)
        attrs   = self._node_attributes(node)
        
        return f'    "{node_id}" [{attrs}];'

    def _format_edge(self, edge) -> str:
        """Format a single edge as DOT."""
        from_id = self._safe_id(self.edge_from_id(edge))
        to_id   = self._safe_id(self.edge_to_id(edge))
        attrs   = self._edge_attributes(edge)
        
        return f'    "{from_id}" -> "{to_id}" [{attrs}];'

    def _node_label(self, node) -> str:
        """Generate label for node."""
        parts = []
        
        if self.config.show_node_path:
            path = self.node_path(node)
            if path:
                parts.append(path)
        
        if self.config.show_node_value:
            value = self.node_value(node)
            if value:
                truncated = self._truncate(value, self.config.max_label_length)
                parts.append(truncated)
        
        return ' | '.join(parts) if parts else self.node_id_str(node)[:8]

    def _node_attributes(self, node) -> str:
        """Generate node attributes string."""
        label      = self._escape(self._node_label(node))
        fillcolor  = self.get_node_style(node, 'fillcolor', self.config.node_fillcolor)
        fontcolor  = self.get_node_style(node, 'fontcolor', self.config.node_fontcolor)
        shape      = self.get_node_style(node, 'shape', self.config.node_shape)
        
        return f'label="{label}", fillcolor="{fillcolor}", fontcolor="{fontcolor}", shape="{shape}"'

    def _edge_attributes(self, edge) -> str:
        """Generate edge attributes string."""
        parts = []
        
        if self.config.show_edge_label:
            predicate = self.edge_predicate(edge)
            edge_path = self.edge_path(edge)
            if predicate or edge_path:
                label = predicate or ''
                if edge_path:
                    label = f'{label}[{edge_path}]' if label else edge_path
                parts.append(f'label="{label}"')
        
        color = self.get_edge_style(edge, 'color', self.config.edge_color)
        parts.append(f'color="{color}"')
        
        return ', '.join(parts)

    def _safe_id(self, id_str: str) -> str:
        """Make ID safe for DOT."""
        return id_str.replace('-', '_').replace(':', '_')

    def _escape(self, text: str) -> str:
        """Escape special characters for DOT."""
        if not text:
            return ''
        return (text.replace('\\', '\\\\')
                    .replace('"', '\\"')
                    .replace('\n', '\\n')
                    .replace('\r', ''))

    def _truncate(self, text: str, max_length: int) -> str:
        """Truncate text with ellipsis."""
        if len(text) <= max_length:
            return text
        return text[:max_length - 3] + '...'
```

### 4.4 D3 Engine

**Location**: `service/mgraph__engines/MGraph__Engine__D3.py`

```python
from typing                                                                    import List, Dict, Any
from mgraph_ai_service_html_graph.service.mgraph__engines.MGraph__Engine__Base import MGraph__Engine__Base, MGraph__Engine__Config__Base


class MGraph__Engine__Config__D3(MGraph__Engine__Config__Base):
    """Configuration for D3.js force-directed engine."""
    
    # Force simulation settings
    charge_strength  : int   = -300       # Node repulsion (negative = repel)
    link_distance    : int   = 50         # Preferred edge length
    collision_radius : int   = 30         # Node collision radius
    center_strength  : float = 0.1        # Pull toward center
    
    # Node defaults
    default_radius   : int   = 20
    default_color    : str   = '#E8E8E8'
    
    # Edge defaults
    default_link_color: str  = '#666666'
    default_link_width: int  = 2
    
    # Label settings
    max_label_length : int   = 30


class MGraph__Engine__D3(MGraph__Engine__Base[MGraph__Engine__Config__D3]):
    """D3.js force-directed rendering engine.
    
    Converts MGraph to D3.js nodes/links format.
    """
    
    config: MGraph__Engine__Config__D3 = None

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        if self.config is None:
            self.config = MGraph__Engine__Config__D3()

    def export(self) -> Dict[str, Any]:
        """Export MGraph to D3.js format."""
        nodes  = [self._format_node(node) for node in self.nodes()]
        links  = [self._format_link(edge) for edge in self.edges()]
        root_id = self._find_root_id()
        
        return {
            'nodes'  : nodes,
            'links'  : links,   # D3 convention: 'links' not 'edges'
            'rootId' : root_id,
            'config' : {
                'chargeStrength' : self.config.charge_strength,
                'linkDistance'   : self.config.link_distance,
                'collisionRadius': self.config.collision_radius,
                'centerStrength' : self.config.center_strength,
            }
        }

    def _format_node(self, node) -> Dict[str, Any]:
        """Format node for D3.js."""
        node_id = self.node_id_str(node)
        label   = self._node_label(node)
        
        return {
            'id'       : node_id,
            'label'    : label,
            'path'     : self.node_path(node) or '',
            'value'    : self.node_value(node),
            'radius'   : self.get_node_style(node, 'radius', self.config.default_radius),
            'color'    : self.get_node_style(node, 'color', self.config.default_color),
            'fontColor': self.get_node_style(node, 'fontColor', '#333333'),
        }

    def _format_link(self, edge) -> Dict[str, Any]:
        """Format edge as D3.js link."""
        return {
            'source'   : self.edge_from_id(edge),
            'target'   : self.edge_to_id(edge),
            'predicate': self.edge_predicate(edge) or '',
            'path'     : self.edge_path(edge) or '',
            'color'    : self.get_edge_style(edge, 'color', self.config.default_link_color),
            'width'    : self.get_edge_style(edge, 'width', self.config.default_link_width),
        }

    def _node_label(self, node) -> str:
        """Generate label for node."""
        value = self.node_value(node)
        if value:
            return self._truncate(value, self.config.max_label_length)
        
        path = self.node_path(node)
        if path:
            return path.split('.')[-1] if '.' in path else path
        
        return self.node_id_str(node)[:8]

    def _find_root_id(self) -> str:
        """Find root node ID (node with no incoming edges)."""
        # Simple heuristic: first node or node with no incoming edges
        if self.nodes():
            return self.node_id_str(self.nodes()[0])
        return ''

    def _truncate(self, text: str, max_length: int) -> str:
        if len(text) <= max_length:
            return text
        return text[:max_length - 3] + '...'
```

### 4.5 Similar Patterns for Other Engines

The following engines follow the same pattern as D3:

| Engine | Config Class | Export Return Type | Key Config Fields |
|--------|--------------|-------------------|-------------------|
| Cytoscape | `MGraph__Engine__Config__Cytoscape` | `dict` (elements.nodes/edges) | layout, spacing, fit |
| VisJs | `MGraph__Engine__Config__VisJs` | `dict` (nodes/edges) | physics, layout, interaction |
| Mermaid | `MGraph__Engine__Config__Mermaid` | `str` (flowchart syntax) | direction, theme |
| Tree | `MGraph__Engine__Config__Tree` | `dict` or `str` | indent, format, max_depth |

---

## 5. Transformation Refactoring

### 5.1 Existing Transformations to Refactor

| Current | New Behavior |
|---------|-------------|
| `Graph_Transformation__Base` (default) | Phase 2: `body_graph.mgraph`, No Phase 3 changes |
| `Graph_Transform__Body_Only` | Phase 2: `body_graph.mgraph` (same as default, may deprecate) |
| `Graph_Transform__Structure_Only` | Phase 3: Filter to element nodes only, no text |
| `Graph_Transform__Attributes_View` | Phase 2: `attrs_graph.mgraph` |
| `Graph_Transform__Clean` | Phase 3: Filter tag/attr nodes, keep element + text |
| `Graph_Transform__Semantic` | Phase 3: Collapse single-child, merge text |

### 5.2 New Transformation: Graph_Transform__Full_Document

**Location**: `service/html_graph__transformations/Graph_Transform__Full_Document.py`

```python
class Graph_Transform__Full_Document(Graph_Transformation__Base):
    """Visualize all 5 subgraphs as a combined graph.
    
    Creates a new MGraph that includes:
    - Head graph nodes (in cluster)
    - Body graph nodes (in cluster)
    - Attributes graph nodes (in cluster)
    - Scripts graph nodes (in cluster)
    - Styles graph nodes (in cluster)
    - Cross-references between clusters
    
    This uses the existing Html_MGraph__Data__Extractor logic.
    """
    
    name        : str = "full_document"
    label       : str = "Full Document"
    description : str = "Visualize complete Html_MGraph with all subgraphs"

    def html_mgraph__to__mgraph(self, html_mgraph: Html_MGraph) -> MGraph:
        """Create combined MGraph from all subgraphs."""
        # Use existing Html_MGraph__Data__Extractor
        extractor = Html_MGraph__Data__Extractor(html_mgraph=html_mgraph)
        extractor.extract()
        
        # Build new MGraph from extracted nodes/edges
        combined = MGraph()
        # ... populate from extractor.nodes and extractor.edges
        # ... add cluster metadata for DOT subgraphs
        
        return combined

    def configure_dot(self, config: MGraph__Engine__Config__Dot) -> None:
        """Configure DOT for multi-cluster layout."""
        config.rankdir = 'LR'  # Left-to-right for wide layout
        config.splines = 'ortho'
        # Enable clustering support
```

### 5.3 Example: Refactored Structure_Only Transformation

```python
class Graph_Transform__Structure_Only(Graph_Transformation__Base):
    """Show page structure without text content."""
    
    name        : str = "structure_only"
    label       : str = "Structure Only"
    description : str = "Page structure without text content"

    def transform_mgraph(self, mgraph: MGraph) -> MGraph:
        """Filter to element nodes only."""
        # Get all node IDs that are NOT text nodes
        nodes_to_keep = set()
        for node in mgraph.data().nodes():
            path = self._get_path(node)
            if path != 'text':  # Keep non-text nodes
                nodes_to_keep.add(node.node_id)
        
        # Remove text nodes
        edit = mgraph.edit()
        for node in list(mgraph.data().nodes()):
            if node.node_id not in nodes_to_keep:
                edit.delete_node(node.node_id)
        
        return mgraph

    def configure_dot(self, config: MGraph__Engine__Config__Dot) -> None:
        """Simpler config for structure view."""
        config.node_fillcolor = '#E3F2FD'  # Light blue for elements
        config.rankdir = 'TB'

    def _get_path(self, node) -> str:
        if hasattr(node, 'node') and hasattr(node.node, 'data'):
            path = node.node.data.node_path
            return str(path) if path else ''
        return ''
```

---

## 6. Refactored Html_Graph__Export__Service

**Location**: `service/html_graph__export/Html_Graph__Export__Service.py`

```python
class Html_Graph__Export__Service(Type_Safe):
    """Unified export service orchestrating the 4-phase pipeline."""

    # ═══════════════════════════════════════════════════════════════════════════
    # Transformation Registry Access
    # ═══════════════════════════════════════════════════════════════════════════

    def list_transformations(self) -> list:
        """Return list of all available transformations."""
        return transformation_registry.list_all()

    def get_transformation(self, name: str) -> Graph_Transformation__Base:
        """Get transformation instance by name."""
        return transformation_registry.get(name)

    # ═══════════════════════════════════════════════════════════════════════════
    # Core Pipeline Execution
    # ═══════════════════════════════════════════════════════════════════════════

    def execute_pipeline(self, html: str, 
                               transformation_name: str = "default"
                        ) -> MGraph:
        """Execute phases 1-3 of the pipeline.
        
        Returns the MGraph ready for engine rendering.
        """
        transformation = self.get_transformation(transformation_name)
        
        # Phase 1: HTML → Html_MGraph
        html_mgraph = transformation.html__to__html_mgraph(html)
        
        # Phase 2: Html_MGraph → MGraph
        mgraph = transformation.html_mgraph__to__mgraph(html_mgraph)
        
        # Phase 3: MGraph → MGraph (transform)
        mgraph = transformation.transform_mgraph(mgraph)
        
        return mgraph

    # ═══════════════════════════════════════════════════════════════════════════
    # Engine Export Methods
    # ═══════════════════════════════════════════════════════════════════════════

    def to_dot(self, request: Schema__Graph__From_Html__Request,
                     transformation: str = "default") -> Schema__Graph__Dot__Response:
        """Export to DOT format."""
        with capture_duration() as duration:
            trans  = self.get_transformation(transformation)
            mgraph = self.execute_pipeline(request.html, transformation)
            
            # Phase 4: Engine rendering
            engine = MGraph__Engine__Dot(mgraph=mgraph)
            trans.configure_dot(engine.config)
            dot_string = engine.export()
            
            # Phase 5: Post-process
            dot_string = trans.transform_export(dot_string)

        return Schema__Graph__Dot__Response(
            dot            = dot_string,
            dot_size       = len(dot_string),
            duration       = duration.seconds,
            transformation = transformation
        )

    def to_d3(self, request: Schema__Graph__From_Html__Request,
                    transformation: str = "default") -> dict:
        """Export to D3.js format."""
        with capture_duration() as duration:
            trans  = self.get_transformation(transformation)
            mgraph = self.execute_pipeline(request.html, transformation)
            
            engine = MGraph__Engine__D3(mgraph=mgraph)
            trans.configure_d3(engine.config)
            data = engine.export()
            
            data = trans.transform_export(data)

        return {
            **data,
            'duration'       : duration.seconds,
            'format'         : 'd3',
            'transformation' : transformation
        }

    def to_cytoscape(self, request, transformation: str = "default") -> dict:
        """Export to Cytoscape.js format."""
        # Same pattern as to_d3
        ...

    def to_visjs(self, request, transformation: str = "default") -> dict:
        """Export to vis.js format."""
        # Same pattern as to_d3
        ...

    def to_mermaid(self, request, transformation: str = "default") -> dict:
        """Export to Mermaid format."""
        # Same pattern as to_dot (returns string)
        ...

    def to_tree(self, request, transformation: str = "default") -> dict:
        """Export to Tree JSON format."""
        ...

    def to_tree_text(self, request, transformation: str = "default") -> dict:
        """Export to Tree text format."""
        ...
```

---

## 7. File Structure

```
mgraph_ai_service_html_graph/
└── service/
    ├── mgraph__engines/                          # NEW DIRECTORY
    │   ├── __init__.py
    │   ├── MGraph__Engine__Base.py               # Base class + config base
    │   ├── MGraph__Engine__Dot.py                # DOT/Graphviz engine
    │   ├── MGraph__Engine__D3.py                 # D3.js engine
    │   ├── MGraph__Engine__Cytoscape.py          # Cytoscape.js engine
    │   ├── MGraph__Engine__VisJs.py              # vis.js engine
    │   ├── MGraph__Engine__Mermaid.py            # Mermaid engine
    │   ├── MGraph__Engine__Tree.py               # Tree view engine
    │   └── configs/                              # OPTIONAL: separate config files
    │       ├── __init__.py
    │       ├── MGraph__Engine__Config__Dot.py
    │       ├── MGraph__Engine__Config__D3.py
    │       └── ...
    │
    ├── html_graph__transformations/              # REFACTORED
    │   ├── __init__.py
    │   ├── Graph_Transformation__Base.py         # Updated 4-phase base
    │   ├── Graph_Transformation__Registry.py     # Add new transformation
    │   ├── Graph_Transform__Body_Only.py         # Refactored
    │   ├── Graph_Transform__Structure_Only.py    # Refactored
    │   ├── Graph_Transform__Attributes_View.py   # Refactored
    │   ├── Graph_Transform__Clean.py             # Refactored
    │   ├── Graph_Transform__Semantic.py          # Refactored
    │   ├── Graph_Transform__Full_Document.py     # NEW
    │   └── Html_Use_Case__Dot_Export.py          # May deprecate
    │
    ├── html_graph__export/                       # REFACTORED
    │   ├── __init__.py
    │   ├── Html_Graph__Export__Service.py        # Simplified orchestrator
    │   ├── Html_MGraph__Data__Extractor.py       # Keep for Full_Document
    │   ├── Html_MGraph__Export__Base.py          # May deprecate
    │   ├── Html_MGraph__To__Cytoscape.py         # DEPRECATED → use engine
    │   ├── Html_MGraph__To__D3.py                # DEPRECATED → use engine
    │   ├── Html_MGraph__To__Mermaid.py           # DEPRECATED → use engine
    │   ├── Html_MGraph__To__Tree_View.py         # DEPRECATED → use engine
    │   └── Html_MGraph__To__VisJs.py             # DEPRECATED → use engine
    │
    └── html_mgraph/                              # UNCHANGED
        └── ...
```

---

## 8. Implementation Order

### Phase 1: Engine Infrastructure (Day 1 Morning)

1. Create `service/mgraph__engines/` directory
2. Implement `MGraph__Engine__Base` with config base
3. Implement `MGraph__Engine__Dot` (most complex, sets pattern)
4. Write tests for DOT engine
5. Implement `MGraph__Engine__D3` (dict output pattern)
6. Write tests for D3 engine

### Phase 2: Remaining Engines (Day 1 Afternoon)

7. Implement `MGraph__Engine__Cytoscape`
8. Implement `MGraph__Engine__VisJs`
9. Implement `MGraph__Engine__Mermaid`
10. Implement `MGraph__Engine__Tree`
11. Write tests for all engines

### Phase 3: Transformation Refactoring (Day 2 Morning)

12. Refactor `Graph_Transformation__Base` to 4-phase model
13. Refactor `Graph_Transform__Structure_Only` (simplest)
14. Refactor `Graph_Transform__Attributes_View`
15. Refactor `Graph_Transform__Clean`
16. Refactor `Graph_Transform__Semantic` (most complex)
17. Evaluate if `Graph_Transform__Body_Only` is redundant
18. Write/update tests for all transformations

### Phase 4: Full Document & Integration (Day 2 Afternoon)

19. Implement `Graph_Transform__Full_Document` using existing extractor
20. Refactor `Html_Graph__Export__Service`
21. Update `Graph_Transformation__Registry`
22. Update FastAPI routes (should be minimal, backward compatible)
23. Integration tests

### Phase 5: Cleanup (Day 2 Evening)

24. Mark deprecated classes
25. Update documentation
26. Final test run
27. Deploy

---

## 9. Backward Compatibility

### API Contract (Unchanged)

```python
# FastAPI routes continue to work exactly the same:
POST /graph/visjs     { "html": "...", "transformation": "default" }
POST /graph/d3        { "html": "...", "transformation": "structure_only" }
POST /graph/dot       { "html": "...", "transformation": "semantic" }
# etc.
```

### Internal Refactoring

- `Html_Graph__Export__Service` methods maintain same signatures
- Transformation names remain the same
- Output formats remain the same
- Only internal implementation changes

### Deprecation Path

The old `Html_MGraph__To__*` classes in `html_graph__export/` will be:
1. Left in place initially (not breaking)
2. Marked with deprecation comments
3. Removed in future version (v1.5.0+)

---

## 10. Testing Strategy

### Unit Tests

| Component | Test File | Key Tests |
|-----------|-----------|-----------|
| `MGraph__Engine__Dot` | `test_MGraph__Engine__Dot.py` | Config application, node/edge formatting, DOT syntax |
| `MGraph__Engine__D3` | `test_MGraph__Engine__D3.py` | Nodes/links structure, config in output |
| `Graph_Transformation__Base` | `test_Graph_Transformation__Base.py` | 4-phase pipeline, callback invocation |
| Each transformation | `test_Graph_Transform__*.py` | Phase 2 selection, Phase 3 filtering |

### Integration Tests

| Test | Description |
|------|-------------|
| `test_Html_Graph__Export__Service.py` | Full pipeline with each engine |
| `test_Routes__Graph.py` | FastAPI endpoints unchanged |
| Round-trip tests | HTML → MGraph → Engine output |

### Regression Tests

- All 978 existing tests should pass
- Output format should match current format

---

## 11. Success Criteria

1. **All 978+ tests pass**
2. **FastAPI routes unchanged** (backward compatible)
3. **4-phase pipeline working** for all transformations
4. **7 engine classes** with typed configs
5. **Per-engine callbacks** in transformations
6. **Full Document transformation** produces multi-cluster DOT
7. **Clean separation** of concerns (no engine code in service)
8. **No performance regression** (same or better)

---

## 12. Open Questions (For Implementer)

1. **Styling metadata storage**: How to store style hints (colors, shapes) on MGraph nodes? Options:
   - Add to `node_data` dict
   - Use separate metadata graph
   - Extend `Schema__MGraph__Node`

2. **Cluster support in DOT**: The `MGraph__Engine__Dot` needs to support subgraph clusters for `Full_Document`. Should this be:
   - Explicit cluster configuration
   - Derived from node metadata (e.g., `cluster_id` attribute)

3. **Tree engine variants**: Currently `to_tree` and `to_tree_text` are separate. Should these be:
   - One engine with `format` config option
   - Two separate engines

---

*Brief Version: 1.0*  
*Created: December 22, 2025*  
*Authors: Claude + DinisCruz*
