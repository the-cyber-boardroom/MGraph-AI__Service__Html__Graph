# Html_MGraph Performance Technical Analysis

**Document Version**: v1.4.7  
**Analysis Date**: December 2025  
**System Under Test**: Html_MGraph Service v1.4.7, MGraph-DB v1.11.0, OSBot-Utils v3.58.0  
**Test Environment**: Python 3.12, macOS

---

## Executive Summary

Performance profiling of the Html_MGraph transformation pipeline reveals significant overhead that limits throughput. A minimal 39-byte HTML document takes **~190ms** to process, with the HTML→Document conversion phase consuming **88-98%** of total execution time. Analysis indicates the bottleneck is **not** memory allocation or node creation, but rather CPU-bound operations during graph construction, likely related to Type_Safe validation and index management.

**Key Findings**:
- Fixed overhead of ~150-200ms regardless of input size
- Super-linear time scaling: O(n^1.5) observed vs expected O(n)
- Memory scales efficiently (sub-linear per element due to value sharing)
- `Html_MGraph__Document().setup()` takes 46.7ms, but 5× raw `MGraph()` takes only 2.6ms
- The gap (44ms) indicates significant overhead in document-specific initialization

---

## 1. Test Methodology

### 1.1 Transformation Pipeline Under Test

```
HTML String → Html_MGraph__Document → HTML String (round-trip)
```

The pipeline consists of two major phases:
- **Phase 1**: `Html__To__Html_MGraph__Document.convert(html)` — Parses HTML and constructs graph
- **Phase 2**: `Html_MGraph__Document__To__Html.convert(doc)` — Serializes graph back to HTML

### 1.2 Html_MGraph__Document Structure

Each document creates **5 interconnected subgraphs**:

| Subgraph | Purpose | Storage Model |
|----------|---------|---------------|
| `body_graph` | Body DOM hierarchy | 1 node per element |
| `head_graph` | Head DOM hierarchy | 1 node per element |
| `attrs_graph` | Attribute storage | 3-4 nodes per attribute |
| `scripts_graph` | Script elements | 1 node per script |
| `styles_graph` | Style elements | 1 node per style |

### 1.3 Test HTML Samples

| Sample | Size | Description |
|--------|------|-------------|
| `minimal` | 39 bytes | `<html><head></head><body></body></html>` |
| `simple` | 120-132 bytes | Basic structure with title and one div |
| `with_attrs` | 368-400 bytes | Multiple elements with several attributes each |
| `complex` | 798-1347 bytes | Full page with nav, article, sidebar, scripts |

---

## 2. Performance Results

### 2.1 Phase Timing Breakdown

#### Initial Profiler Run

| Sample | Input Size | Phase 1 (HTML→Doc) | Phase 2 (Doc→HTML) | Total | Phase 1 % |
|--------|------------|--------------------|--------------------|-------|-----------|
| minimal | 39 B | 109.33 ms | 2.09 ms | 111.46 ms | **98.1%** |
| simple | 132 B | 174.14 ms | 22.76 ms | 196.93 ms | **88.4%** |
| with_attrs | 400 B | 1,375.59 ms | 124.56 ms | 1,500.24 ms | **91.7%** |
| complex | 1,347 B | 3,601.51 ms | 211.47 ms | 3,813.07 ms | **94.5%** |

#### Subsequent Test Run (5 iterations averaged)

| Sample | Input Size | Avg Time | Std Dev | Body Nodes | Attr Nodes |
|--------|------------|----------|---------|------------|------------|
| minimal | 39 B | 194.19 ms | ±123.76 | 2 | 8 |
| simple | 120 B | 186.95 ms | ±11.92 | 5 | 20 |
| with_attrs | 368 B | 161.20 ms | ±5.55 | 6 | 55 |
| medium | 798 B | 331.90 ms | ±75.86 | 29 | 85 |

**Observation**: High variance in minimal case (±123ms) suggests JIT warm-up or GC effects.

### 2.2 Phase Breakdown (Medium HTML)

```
Phase                   Time        Percentage
─────────────────────────────────────────────
HTML → Document      2,942.93 ms     86.1%
Document → HTML        476.22 ms     13.9%
─────────────────────────────────────────────
Total                3,419.15 ms    100.0%

⚠ HTML→Document is 6.2× slower than Document→HTML
```

### 2.3 Throughput Analysis

| Sample | Size | Time | Throughput |
|--------|------|------|------------|
| minimal | 39 B | 194 ms | 0.20 KB/s |
| simple | 120 B | 187 ms | 0.64 KB/s |
| with_attrs | 368 B | 161 ms | 2.29 KB/s |
| medium | 798 B | 332 ms | 2.40 KB/s |

**Observation**: Throughput improves with size, confirming fixed overhead dominates small inputs.

---

## 3. Scalability Analysis

### 3.1 Element Count Scaling

Test: Generate HTML with N elements, each containing attributes.

| Elements | Input Size | Time | Body Nodes | ms/element |
|----------|------------|------|------------|------------|
| 3 | 85 B | 234.16 ms | — | — |
| 5 | 197 B | 318.55 ms | — | — |
| 10 | 337 B | 386.08 ms | — | — |
| 25 | 772 B | 553.58 ms | — | — |
| 50 | 1,497 B | 1,006.60 ms | — | — |
| 100 | 2,947 B | 2,168.93 ms | — | — |

### 3.2 Detailed Scalability Run

| Elements | Time | Body Nodes | ms/element | Delta from baseline |
|----------|------|------------|------------|---------------------|
| 3 | 366.24 ms | 18 | 122.08 | baseline |
| 7 | 699.72 ms | 38 | 99.96 | ↓18% (warming) |
| 10 | 931.90 ms | 53 | 93.19 | ↓24% (optimal) |
| 20 | 2,549.64 ms | 103 | 127.48 | ↑4% (degrading) |
| 30 | 5,434.60 ms | 153 | 181.15 | ↑48% (significant) |

**Growth Factor**: 1.48× (last ms/element ÷ first ms/element)

### 3.3 Scaling Characteristics

```
Expected O(n):   30 elements ≈ 3× time of 10 elements = ~2,800 ms
Actual:          30 elements = 5,435 ms (1.94× worse than linear)

Estimated complexity: O(n^1.5) or O(n log n) with high constant
```

**Visual representation**:
```
Time (ms)
    │
5500├────────────────────────────────────────×
    │                                      ╱
4500├────────────────────────────────────╱──
    │                                  ╱
3500├────────────────────────────────╱────── Expected O(n)
    │                              ╱        would be here
2500├───────────────────────────×───────────
    │                         ╱
1500├─────────────────────────────────────── 
    │              ×      ╱
 500├────×────×─────────────────────────────
    │    
    └────┬────┬────┬─────┬─────┬─────┬────
         3    7   10    20    30   Elements
```

---

## 4. Memory Analysis

### 4.1 Memory Usage by Element Count

| Elements | Current | Peak | Input Size | Memory/Input Ratio |
|----------|---------|------|------------|-------------------|
| 10 | 912.8 KB | 938.8 KB | 1.4 KB | 653.5× |
| 20 | 1,451.0 KB | 1,498.0 KB | 2.8 KB | 539.9× |
| 30 | 1,890.7 KB | 1,959.0 KB | 4.1 KB | 476.4× |

### 4.2 Per-Element Memory

| Elements | Total Memory | KB/element | Delta |
|----------|--------------|------------|-------|
| 10 | 913 KB | 91.3 KB | baseline |
| 20 | 1,451 KB | 72.6 KB | ↓20% |
| 30 | 1,891 KB | 63.0 KB | ↓31% |

**Observation**: Memory per element **decreases** as graph grows, confirming value node sharing is effective. The 3-node attribute model reuses name and value nodes across elements.

### 4.3 Memory vs Time Comparison

| Factor | 10→30 Elements | Scaling |
|--------|----------------|---------|
| Node count | 53 → 153 | 2.9× (linear ✓) |
| Memory | 913 → 1891 KB | 2.1× (sub-linear ✓) |
| **Time** | 932 → 5435 ms | **5.8×** (super-linear ✗) |

**Conclusion**: Time scaling is the anomaly. Memory and node count scale properly.

---

## 5. Node Creation Analysis

### 5.1 Node Multiplication Factor

| Case | HTML Elements | Body Nodes | Attr Nodes | Total | Multiplier |
|------|---------------|------------|------------|-------|------------|
| minimal | 3 | 2 | 8 | 10 | 3.3× |
| simple | 5 | 5 | 20 | 25 | 5.0× |
| with_attrs | 6 | 6 | 55 | 61 | 10.2× |
| medium | ~20 | 29 | 85 | 114 | 5.7× |

**Observation**: Attribute-heavy HTML has higher multiplication factor due to 3-node attribute model.

### 5.2 Attribute Node Efficiency

Test: 20 attributes per element (40 total attributes across 2 elements)

```
Expected (3-node model): 40 attrs × 3 nodes = 120 nodes minimum
Actual: 92 nodes
Overhead factor: 0.77× (23% savings from node reuse)
```

**Conclusion**: Value sharing is working — common attribute names are deduplicated.

---

## 6. Initialization Overhead Analysis

### 6.1 Isolated Initialization Test

```python
# Test 1: Full document initialization
Html_MGraph__Document().setup()
Result: 46.7 ms

# Test 2: Raw MGraph initialization (×5)
for _ in range(5): MGraph()
Result: 2.6 ms
```

### 6.2 Initialization Breakdown

| Component | Time | Notes |
|-----------|------|-------|
| 5× raw `MGraph()` | 2.6 ms | Base graph structures |
| `Html_MGraph__Document().setup()` | 46.7 ms | Full document with subgraphs |
| **Gap** | **44.1 ms** | Document-specific initialization |

### 6.3 Estimated Overhead Sources

| Source | Estimated Time | Evidence |
|--------|----------------|----------|
| Type_Safe class initialization | ~20-30 ms | Complex inheritance hierarchy |
| Index structure creation | ~10-15 ms | 12+ index dictionaries per graph |
| Subgraph wiring/setup | ~5-10 ms | Cross-references between graphs |
| **Total estimated** | ~35-55 ms | Matches observed 44ms gap |

---

## 7. Identified Bottlenecks

### 7.1 Primary Bottleneck: Phase 1 Construction

**Evidence**:
- Phase 1 consumes 88-98% of total time
- 6.2× slower than Phase 2 serialization
- Scaling degrades with element count

**Location**: `Html__To__Html_MGraph__Document.convert()`

### 7.2 Secondary Bottleneck: Fixed Initialization Overhead

**Evidence**:
- Minimal HTML (39 bytes, 2 body nodes) takes 194ms
- Document setup alone takes 46.7ms
- Throughput improves with larger inputs

**Impact**: Dominates performance for small documents

### 7.3 Tertiary Bottleneck: Super-linear Scaling

**Evidence**:
- ms/element increases from 93ms (10 elem) to 181ms (30 elem)
- Growth factor of 1.48× observed
- Memory and node count scale linearly, but time does not

**Likely Cause**: O(n) or O(n²) operations during construction:
- Index updates that scan existing entries
- Type_Safe validation traversing inheritance
- Edge validation checking node existence

---

## 8. Hypotheses

### 8.1 Hypothesis A: Index Update Scaling

**Theory**: Each node/edge creation updates 12+ indexes. Some index operations may scan existing entries.

```python
# Pseudocode - potential O(n²) pattern
def add_node(node):
    for index in all_indexes:           # 12+ indexes
        index.add(node)                 # May involve lookups
        if index.needs_validation():
            for existing in index:      # O(n) scan
                validate(existing, node)
```

**Test**: Profile index update time at different graph sizes.

### 8.2 Hypothesis B: Type_Safe Validation Overhead

**Theory**: Every attribute assignment triggers `__setattr__` validation, which may:
- Traverse class hierarchy for type hints
- Perform isinstance checks
- Attempt type conversions

**Test**: Compare time for Type_Safe objects vs plain Python objects.

### 8.3 Hypothesis C: BeautifulSoup Not the Culprit

**Evidence**: Initial profiler showed BeautifulSoup parsing is fast (~1-5ms for small docs). The time is spent after parsing, during graph construction.

### 8.4 Hypothesis D: Value Uniqueness Checking

**Theory**: Every value node creation:
1. Serializes value to string
2. Computes hash
3. Looks up in `hash_to_node` dictionary
4. May have hash collisions requiring equality checks

**Test**: Profile `get_or_create_value_node()` at different graph sizes.

---

## 9. Comparative Analysis

### 9.1 Time per Operation Type

| Operation | Approx Time | Scales With |
|-----------|-------------|-------------|
| Document init | 46.7 ms | Fixed |
| Per body node | ~3-5 ms | Element count |
| Per attribute | ~10-20 ms | Attribute count |
| Serialization | ~0.1-0.5 ms/node | Node count |

### 9.2 Cost Model (Estimated)

```
Total Time ≈ 47ms (init) 
           + 5ms × body_nodes 
           + 15ms × attributes 
           + scaling_penalty(n)

Where scaling_penalty(n) ≈ 0.5ms × n × log(n)
```

### 9.3 Expected vs Actual (30 elements)

```
Expected (linear):
  47ms + (30 × 5ms) + (60 attrs × 15ms) = 47 + 150 + 900 = 1,097ms

Actual: 5,435ms

Unexplained overhead: 4,338ms (4× expected)
```

---

## 10. Recommendations for Investigation

### 10.1 High Priority

1. **Profile inside `Html__To__Html_MGraph__Document.convert()`**
   - Break down into sub-phases: parsing, body construction, attrs construction
   - Identify which sub-phase shows super-linear scaling

2. **Profile MGraph index operations**
   - Measure time per `add_node()` at different graph sizes
   - Check for O(n) scans in index update code

3. **Profile Type_Safe `__setattr__`**
   - Measure validation overhead per assignment
   - Compare with `object.__setattr__` baseline

### 10.2 Medium Priority

4. **Test with index updates disabled**
   - Implement bulk mode that defers indexing
   - Measure construction time without index overhead

5. **Profile value node uniqueness checking**
   - Measure hash computation time
   - Check for collision handling overhead

### 10.3 Low Priority

6. **Evaluate alternative parsing**
   - Test lxml vs html.parser vs html5lib
   - Consider direct-to-graph parsing (skip intermediate dict)

---

## 11. Summary Statistics

### Performance Summary Table

| Metric | Value | Status |
|--------|-------|--------|
| Minimum viable time | ~190ms | ⚠ High |
| Phase 1 dominance | 88-98% | ⚠ Imbalanced |
| Time scaling | O(n^1.5) | ⚠ Super-linear |
| Memory scaling | O(n) sub-linear | ✓ Good |
| Node scaling | O(n) linear | ✓ Good |
| Init overhead | 46.7ms | ⚠ Significant |
| Value node reuse | 23% savings | ✓ Working |

### Key Numbers to Remember

```
┌─────────────────────────────────────────────────────────┐
│  BASELINE OVERHEAD         │  ~190ms (minimal HTML)    │
│  DOCUMENT INIT             │  46.7ms                   │
│  PHASE 1 DOMINANCE         │  88-98% of total time     │
│  SCALING DEGRADATION       │  1.48× growth factor      │
│  MEMORY EFFICIENCY         │  23% savings from reuse   │
│  CONSTRUCTION:SERIALIZE    │  6.2:1 ratio              │
└─────────────────────────────────────────────────────────┘
```

---

## 12. Appendix: Raw Data

### A.1 Initial Profiler Output (Run 1)

```
minimal:    111.46ms total (109.33ms Phase1, 2.09ms Phase2)
simple:     196.93ms total (174.14ms Phase1, 22.76ms Phase2)
with_attrs: 1500.24ms total (1375.59ms Phase1, 124.56ms Phase2)
complex:    3813.07ms total (3601.51ms Phase1, 211.47ms Phase2)
```

### A.2 Scalability Data Points

```
Elements: [1, 5, 10, 25, 50, 100]
Sizes:    [85, 197, 337, 772, 1497, 2947] bytes
Times:    [234.16, 318.55, 386.08, 553.58, 1006.60, 2168.93] ms
```

### A.3 Memory Data Points

```
Elements: [10, 20, 30]
Current:  [912.8, 1451.0, 1890.7] KB
Peak:     [938.8, 1498.0, 1959.0] KB
Input:    [1.4, 2.8, 4.1] KB
```

---

*Document generated from performance analysis session, December 2025*
