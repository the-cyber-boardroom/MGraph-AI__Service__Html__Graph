# Technical Review: Event-Driven Server Reload Detection for IFD Workflows

**Versions:** 0.1.10 (server) v0.2.20 (UI)
**Date:** December 2024  
  

---

## Executive Summary

This document details the design, implementation challenges, and solution for an event-driven server reload detection system. The system enables zero-context-switch development workflows where backend code changes automatically trigger frontend re-renders.

---

## Problem Statement

### The Development Workflow Challenge

In an Iterative Flow Development (IFD) workflow, developers often work across multiple machines or need rapid feedback loops:

```
┌─────────────────────┐          ┌─────────────────────┐
│   Dev Laptop 1      │          │   Dev Laptop 2      │
│   (Code Editing)    │          │   (UI Testing)      │
├─────────────────────┤          ├─────────────────────┤
│ - IDE               │          │ - Browser           │
│ - FastAPI server    │ ◄──────► │ - Playground UI     │
│ - Backend code      │  HTTP    │ - Graph rendering   │
└─────────────────────┘          └─────────────────────┘
```

**The typical workflow:**
1. Developer edits backend code on Laptop 1
2. FastAPI's `--reload` detects file change and restarts server (~200ms)
3. Developer switches to Laptop 2
4. Manually presses 'R' to reload the graph
5. Views the result of backend changes

**The friction point:** Steps 3-4 require a context switch - physically moving attention to another machine and triggering a manual action. This breaks flow state.

### Requirements

| Requirement | Description |
|-------------|-------------|
| **Event-driven** | No polling timers running constantly |
| **Zero latency** | Detect server restart as it happens |
| **Non-blocking** | Must not interfere with FastAPI's hot reload |
| **Resilient** | Handle network interruptions gracefully |
| **Toggleable** | Developer can enable/disable the feature |

---

## Solution Architecture

### Server-Sent Events (SSE) Approach

SSE was chosen over WebSockets for simplicity - it's unidirectional (server → client), uses standard HTTP, and browsers handle reconnection automatically via `EventSource`.

#### Server Component (FastAPI)

```python
def add_event_stream(self):
    from fastapi.responses import StreamingResponse
    import asyncio
    import time

    SERVER_START_TIME = time.time()  # Captured at module load = unique per restart

    async def server_events():
        async def event_stream():
            yield f"data: {SERVER_START_TIME}\n\n"  # Immediate timestamp
            while True:
                await asyncio.sleep(30)             # Keep-alive
                yield f": heartbeat\n\n"            # SSE comment (ignored by client)

        return StreamingResponse(event_stream(), media_type="text/event-stream")

    self.app().add_api_route("/events/server", server_events, methods=["GET"])
```

**Key design decisions:**

| Decision | Rationale |
|----------|-----------|
| `time.time()` at module load | Guarantees unique value per server process |
| Immediate `data:` yield | Client gets timestamp before any heartbeat delay |
| 30-second heartbeat | Keeps connection alive through proxies/load balancers |
| SSE comment format (`: heartbeat`) | Valid SSE but doesn't trigger `onmessage` |

#### Client Component (JavaScript)

```javascript
this.eventSource = new EventSource('/events/server');

this.eventSource.onmessage = function(event) {
    var serverTime = event.data.trim();
    
    if (self.lastServerTime && serverTime !== self.lastServerTime) {
        // Server restarted - timestamp changed
        setTimeout(function() {
            self.onReload();  // Trigger graph re-render
        }, 500);             // Small delay for server to fully initialize
    }
    
    self.lastServerTime = serverTime;
};
```

**EventSource auto-reconnect behavior:**
- Connection drops → browser waits ~3 seconds → auto-reconnects
- On reconnect, server sends new `SERVER_START_TIME`
- Client compares with stored value → detects restart

---

## The Blocking Problem

### Symptom

When FastAPI's `--reload` detected a file change:

```
WARNING: StatReload detected changes in '...Html_Use_Case__1.py'. Reloading...
INFO:    Shutting down
INFO:    Waiting for connections to close. (CTRL+C to force quit)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
         Hangs here indefinitely
```

### Root Cause Analysis

The issue involves three interacting systems:

#### 1. Python's Async Generator Lifecycle

```python
async def event_stream():
    yield f"data: {SERVER_START_TIME}\n\n"
    while True:
        await asyncio.sleep(30)  # ← Blocked here when shutdown requested
        yield f": heartbeat\n\n"
```

When shutdown is requested:
- `asyncio.sleep(30)` is a pending coroutine
- Python's async runtime must cancel it
- The generator must be properly closed (`GeneratorExit`)

#### 2. Starlette's StreamingResponse

```python
# Simplified Starlette internals
class StreamingResponse:
    async def stream_response(self, send):
        async for chunk in self.body_iterator:  # ← Waits for generator
            await send({"type": "http.response.body", "body": chunk})
```

Starlette iterates the async generator until completion. During shutdown, it waits for the current `await` to complete.

#### 3. Uvicorn's Graceful Shutdown

```python
# Simplified uvicorn shutdown logic
async def shutdown(self):
    # Signal workers to stop accepting new connections
    self.should_exit = True
    
    # Wait for existing connections to complete
    while self.connections:
        await asyncio.sleep(0.1)  # ← Waits here
        if time.time() - start > self.timeout_graceful_shutdown:
            break
```

**Default `timeout_graceful_shutdown`:** None (wait forever)

### The Deadlock

```
┌─────────────────────────────────────────────────────────────────┐
│                        SHUTDOWN SEQUENCE                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Uvicorn                    Starlette              Generator    │
│  ───────                    ─────────              ─────────    │
│     │                          │                       │        │
│     │ shutdown signal          │                       │        │
│     ├─────────────────────────►│                       │        │
│     │                          │                       │        │
│     │ waiting for              │ waiting for           │        │
│     │ connections...           │ generator...          │ await  │
│     │         ▲                │        ▲              │ sleep  │
│     │         │                │        │              │   │    │
│     │         └────────────────┴────────┴──────────────┴───┘    │
│     │                                                           │
│     │              CIRCULAR WAIT (DEADLOCK)                     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## Attempted Solutions

### Attempt 1: Catch CancelledError

```python
async def event_stream():
    try:
        yield f"data: {SERVER_START_TIME}\n\n"
        while True:
            await asyncio.sleep(30)
            yield f": heartbeat\n\n"
    except asyncio.CancelledError:
        pass  # Graceful exit
```

**Result:** ❌ Failed

**Why:** The `CancelledError` is raised inside `asyncio.sleep()`, but by the time it propagates, Starlette's response handler has already committed to waiting.

### Attempt 2: Shutdown Flag with Short Sleep

```python
shutdown_flag = {"value": False}

@app.on_event("shutdown")
async def on_shutdown():
    shutdown_flag["value"] = True

async def event_stream():
    yield f"data: {SERVER_START_TIME}\n\n"
    while not shutdown_flag["value"]:
        await asyncio.sleep(1)  # Check every 1 second
        yield f": heartbeat\n\n"
```

**Result:** ❌ Failed

**Why:** The `on_event("shutdown")` handler runs *after* uvicorn has already started waiting for connections. The flag is set too late.

### Attempt 3: Combined Exception Handling

```python
async def event_stream():
    yield f"data: {SERVER_START_TIME}\n\n"
    try:
        while True:
            await asyncio.sleep(5)
            yield f": heartbeat\n\n"
    except (asyncio.CancelledError, GeneratorExit):
        return
```

**Result:** ❌ Failed

**Why:** Same fundamental issue - the exception handling is correct, but uvicorn's shutdown logic doesn't force-cancel the tasks by default.

---

## The Solution

### Uvicorn's `--timeout-graceful-shutdown` Flag

```bash
poetry run uvicorn app:app --reload --host 0.0.0.0 --port $PORT \
    --timeout-graceful-shutdown 0
```

**What this does:**

```python
# Uvicorn with timeout_graceful_shutdown=0
async def shutdown(self):
    self.should_exit = True
    
    # timeout=0 means: don't wait at all
    if self.timeout_graceful_shutdown == 0:
        for connection in self.connections:
            connection.shutdown()  # Force close immediately
        return
    
    # ... normal waiting logic
```

### Why This Works

| Without Flag | With `--timeout-graceful-shutdown 0` |
|--------------|--------------------------------------|
| Uvicorn waits for connections | Uvicorn force-closes connections |
| Generator keeps running | Connection dropped immediately |
| Deadlock | Clean shutdown in <100ms |

### Trade-offs

| Aspect | Impact |
|--------|--------|
| **In-flight requests** | Terminated mid-response |
| **SSE connections** | Dropped (client auto-reconnects) |
| **WebSocket connections** | Dropped without close frame |
| **File uploads** | Interrupted |

**For development with `--reload`:** These trade-offs are acceptable. The whole point is rapid iteration.

**For production:** Don't use `--timeout-graceful-shutdown 0`. Use proper graceful shutdown with reasonable timeout (e.g., 30 seconds).

---

## Complete System Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           COMPLETE FLOW DIAGRAM                             │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  Developer          FastAPI Server              Browser (EventSource)       │
│  ─────────          ──────────────              ─────────────────────       │
│      │                    │                              │                  │
│      │                    │◄─────── SSE Connection ──────┤                  │
│      │                    │                              │                  │
│      │                    │ ─── data: 1766082209.5 ────► │                  │
│      │                    │                              │ lastServerTime   │
│      │                    │                              │ = 1766082209.5   │
│      │                    │ ─────── : heartbeat ───────► │                  │
│      │                    │                              │                  │
│   Edit code               │                              │                  │
│      │                    │                              │                  │
│   Save file               │                              │                  │
│      │                    │                              │                  │
│      │              StatReload detects                   │                  │
│      │              change, triggers                     │                  │
│      │              shutdown                             │                  │
│      │                    │                              │                  │
│      │              --timeout-graceful-                  │                  │
│      │              shutdown 0                           │                  │
│      │              FORCE CLOSE ─────────────────────────X (connection)     │
│      │                    │                              │                  │
│      │              Server restarts                      │ onerror fired    │
│      │              SERVER_START_TIME                    │                  │
│      │              = 1766082215.3                       │                  │
│      │                    │                              │                  │
│      │                    │◄─── EventSource reconnects ──┤ (auto, ~3 sec)   │
│      │                    │                              │                  │
│      │                    │ ─── data: 1766082215.3 ────► │                  │
│      │                    │                              │                  │
│      │                    │                              │ 1766082215.3 !=  │
│      │                    │                              │ 1766082209.5     │
│      │                    │                              │                  │
│      │                    │                              │ SERVER RESTART   │
│      │                    │                              │ DETECTED!        │
│      │                    │                              │                  │
│      │                    │◄────── renderGraph() ────────┤                  │
│      │                    │                              │                  │
│      │                    │ ────── graph response ──────►│                  │
│      │                    │                              │                  │
│      │                    │                              │ UI updates with  │
│      │                    │                              │ new graph        │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Alternative Approaches Considered

### 1. Polling (Fallback Option)

```javascript
setInterval(function() {
    fetch('/server/status')
        .then(r => r.json())
        .then(data => {
            if (lastTime && data.server_start !== lastTime) {
                triggerReload();
            }
            lastTime = data.server_start;
        });
}, 2000);
```

| Pros | Cons |
|------|------|
| Simple, no blocking issues | 2-second latency |
| Works with any server | Constant network traffic |
| No special uvicorn flags | Not truly event-driven |

### 2. WebSocket

```python
@app.websocket("/ws/dev")
async def dev_websocket(websocket: WebSocket):
    await websocket.accept()
    await websocket.send_json({"server_start": SERVER_START_TIME})
    while True:
        await asyncio.sleep(30)
        await websocket.send_json({"type": "heartbeat"})
```

| Pros | Cons |
|------|------|
| Bidirectional (future features) | Same blocking issue |
| Lower overhead than SSE | More complex client code |
| | No auto-reconnect in browser |

### 3. File Watcher on Client

```javascript
// Watch a version file via polling
fetch('/static/version.txt?t=' + Date.now())
```

| Pros | Cons |
|------|------|
| No server changes | Requires file system access |
| Works offline | Polling overhead |
| | Doesn't detect code-only changes |

---

## Case Study: Zero Context-Switch Development in PyCharm

### Setup

The ultimate realization of this solution eliminates context switching entirely by embedding the browser within the IDE.

**Configuration:**
- **IDE:** PyCharm with built-in browser preview
- **Left Panel:** Python source code (`Html_Use_Case__1.py`)
- **Right Panel:** Built-in browser showing `http://localhost:10020/console/v0/v0.2/v0.2.10/playground.html`
- **Server:** FastAPI with `--reload` and `--timeout-graceful-shutdown 0`

### The Workflow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          PyCharm IDE Window                                 │
├───────────────────────────────────┬─────────────────────────────────────────┤
│                                   │                                         │
│   Html_Use_Case__1.py             │   Preview of playground.html            │
│   ───────────────────             │   ────────────────────────              │
│                                   │                                         │
│   class Html_Use_Case__1(...):    │   ┌─────────────────────────────┐       │
│                                   │   │  DOT / Graphviz    ▼        │       │
│     def transform_mgraph(...):    │   │                             │       │
│       nodes = html_mgraph...      │   │      ┌───────────┐          │       │
│       for node_id, node in ...:   │   │      │ html.body │          │       │
│         if node.node_path ==      │   │      └─────┬─────┘          │       │
│              'text':              │   │            │                │       │
│           node.node_path =        │   │    ┌──────┴──────┐          │       │
│   >>>       "CHANGED - and        │   │    ▼             ▼          │       │
│              reloaded"            │   │ ┌──────┐    ┌──────┐        │       │
│                                   │   │ │CHANG │    │CHANG │        │       │
│       return html_mgraph          │   │ │ED_and│    │ED_and│        │       │
│                                   │   │ │reload│    │reload│        │       │
│                                   │   │ └──────┘    └──────┘        │       │
│                                   │   │                             │       │
│                                   │   └─────────────────────────────┘       │
│                                   │                                         │
│                                   │   ┌─────────────────────────────┐       │
│                                   │   │ Server restarted - reload.. │       │
│                                   │   └─────────────────────────────┘       │
│                                   │              (toast)                    │
│                                   │                                         │
├───────────────────────────────────┴─────────────────────────────────────────┤
│ Terminal: poetry run uvicorn ... --reload --timeout-graceful-shutdown 0     │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Step-by-Step

1. **Developer edits code** in the left panel
   - Changes `node.node_path = "CHANGED - and reloaded"`
   
2. **Saves file** (Cmd+S / Ctrl+S)
   - File saved to disk

3. **FastAPI detects change** (automatic, ~100ms)
   - StatReload triggers: `WARNING: StatReload detected changes...`
   - Server shuts down immediately (`--timeout-graceful-shutdown 0`)
   - SSE connection drops

4. **Server restarts** (automatic, ~500ms)
   - New `SERVER_START_TIME` generated
   - SSE endpoint available

5. **Browser reconnects** (automatic, ~3s)
   - `EventSource` auto-reconnect
   - Receives new timestamp
   - Detects mismatch → triggers reload

6. **Graph re-renders** (automatic)
   - Toast appears: "Server restarted - reloading..."
   - `renderGraph()` called
   - New graph shows updated node labels

7. **Developer sees result** in the right panel
   - Graph nodes now show "CHANGED__and_reloaded"
   - **Total time:** ~4 seconds
   - **Context switches:** Zero

### Benefits Realized

| Metric | Traditional Workflow | With Auto-Reload |
|--------|---------------------|------------------|
| Context switches | 2 (to browser, back to IDE) | 0 |
| Manual actions | 1 (press 'R') | 0 |
| Cognitive interruption | High | None |
| Time to feedback | ~10-15 seconds | ~4 seconds |
| Flow state preserved | ❌ Broken | ✅ Maintained |

### Configuration Required

**run-locally.sh:**
```bash
#!/bin/bash
PORT=10020

poetry run uvicorn \
    mgraph_ai_service_html_graph.fast_api.lambda_handler:app \
    --reload \
    --host 0.0.0.0 \
    --port $PORT \
    --log-level info \
    --no-access-log \
    --timeout-graceful-shutdown 0
```

**PyCharm Setup:**
1. Open any HTML file in the project
2. Click the browser icon in the top-right corner
3. Select "Built-in Preview"
4. Navigate to `http://localhost:10020/console/v0/v0.2/v0.2.10/playground.html`
5. Enable "Auto-reload" toggle in the UI

---

## Implementation Files

### File Structure (v0.2.10)

```
v0.2.10/
├── playground.html              # Entry point with script chain
├── css/
│   └── server-reload.css        # Toggle button and toast styles
└── js/
    ├── server-reload-detector.js # SSE client logic
    └── playground.js             # Surgical patch for integration
```

### Key Files

**server-reload-detector.js** - Core detection logic:
- `EventSource` connection management
- Timestamp comparison
- Auto-reconnect handling
- localStorage persistence for toggle state

**playground.js** - Integration patch:
- Initializes `ServerReloadDetector`
- Adds toggle button to toolbar
- Connects reload callback to `renderGraph()`

**server-reload.css** - UI components:
- Toggle button (inactive/active states)
- Toast notification styling

---

## Production Considerations

This solution is **development-only**. For production:

| Development | Production |
|-------------|------------|
| `--timeout-graceful-shutdown 0` | `--timeout-graceful-shutdown 30` |
| Single developer | Multiple users |
| Rapid iteration | Graceful degradation |
| Acceptable to drop connections | Must complete in-flight requests |

### Production Alternative

For production hot-reload scenarios (e.g., zero-downtime deployments):

1. **Blue-green deployment:** New server starts before old stops
2. **Load balancer health checks:** Route traffic to healthy instance
3. **Client-side version check:** Compare `X-App-Version` header

---

## Conclusion

The SSE-based server reload detection provides a true event-driven solution for IFD workflows. The key insight was understanding the interaction between Python's async generators, Starlette's streaming response handler, and uvicorn's graceful shutdown logic.

The `--timeout-graceful-shutdown 0` flag resolves the deadlock by instructing uvicorn to immediately terminate connections rather than waiting for generators to complete naturally.

**Result:** Zero context-switch development workflow where backend code changes automatically trigger frontend re-renders.

### Key Takeaways

1. **SSE + `EventSource`** provides automatic reconnection for free
2. **Async generators** can cause shutdown deadlocks without proper timeout configuration
3. **`--timeout-graceful-shutdown 0`** is safe and appropriate for development with `--reload`
4. **IDE-embedded browsers** eliminate all context switching
5. **The solution is surgical** - minimal code changes, maximum workflow improvement

---

## References

- [Uvicorn Settings Documentation](https://www.uvicorn.org/settings/)
- [Server-Sent Events (SSE) Specification](https://html.spec.whatwg.org/multipage/server-sent-events.html)
- [FastAPI StreamingResponse](https://fastapi.tiangolo.com/advanced/custom-response/#streamingresponse)
- [IFD (Iterative Flow Development) Methodology](./v1_2_1__ifd__intro-and-how-to-use.md)