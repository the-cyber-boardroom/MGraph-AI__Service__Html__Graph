# IFD Snapshot Generator - LLM Implementation Brief

**Version**: v1.4.10  
**Purpose**: Implementation guide for building the IFD Snapshot Generator service  
**Dependencies**: MGraph-DB v1.10.6+, Html_MGraph Service v1.4.0+

---

## Executive Summary

The **IFD Snapshot Generator** is a Python service that programmatically extracts all dependencies from an IFD minor version's HTML entry point and creates a self-contained "snapshot" folder. This enables clean consolidation from minor versions to major versions by eliminating scattered files across version folders.

**Key Principle**: This is a **programmatic transformation** with **zero LLM involvement**. The output is deterministic and auditable.

---

## Table of Contents

1. [Problem Statement](#1-problem-statement)
2. [Solution Architecture](#2-solution-architecture)
3. [Pipeline Overview](#3-pipeline-overview)
4. [Data Structures](#4-data-structures)
5. [Component Specifications](#5-component-specifications)
6. [File Naming Conventions](#6-file-naming-conventions)
7. [Implementation Details](#7-implementation-details)
8. [Error Handling](#8-error-handling)
9. [Testing Strategy](#9-testing-strategy)
10. [Usage Examples](#10-usage-examples)
11. [API Reference](#11-api-reference)

---

## 1. Problem Statement

### Current Pain Point

When consolidating IFD minor versions (e.g., `v1.1.x`) into a major version (`v1.2.0`), files are scattered across multiple version folders due to the surgical override pattern:

```
v1.1.0/components/config-panel/config-panel.js  (base - 500 lines)
v1.1.3/components/config-panel/config-panel.js  (patch - 15 lines)
v1.1.5/components/config-panel/config-panel.js  (patch - 20 lines)
v1.1.2/css/common.css                           (unrelated file)
v1.1.4/js/some-feature.js                       (unrelated file)
```

**Problem**: LLMs attempting to merge these files get overwhelmed by irrelevant context, producing buggy outputs that destroy developer trust.

### Solution

Create an intermediate **snapshot** step that:
1. Parses the HTML entry point to discover all dependencies
2. Extracts only the files actually used
3. Copies them into a single self-contained folder
4. Generates a manifest documenting the load order and provenance

---

## 2. Solution Architecture

### High-Level Architecture

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                       IFD SNAPSHOT GENERATOR                                │
└─────────────────────────────────────────────────────────────────────────────┘

                    ┌──────────────────────────────────────┐
                    │         IFD_Snapshot_Generator       │
                    │                                      │
                    │  • parse_html_entry_point()          │
                    │  • extract_dependencies()            │
                    │  • build_load_chains()               │
                    │  • generate_snapshot()               │
                    └───────────────┬──────────────────────┘
                                    │
         ┌──────────────────────────┼──────────────────────────┐
         │                          │                          │
         ▼                          ▼                          ▼
┌─────────────────┐     ┌─────────────────────┐    ┌─────────────────────┐
│  Html_MGraph    │     │  Dependency_Graph   │    │  Snapshot_Writer    │
│  Service        │     │  Builder            │    │                     │
│                 │     │                     │    │  • copy_files()     │
│  (existing)     │     │  • resolve_paths()  │    │  • transform_html() │
│                 │     │  • detect_chains()  │    │  • write_manifest() │
└─────────────────┘     │  • classify_types() │    └─────────────────────┘
                        └─────────────────────┘
```

### Component Breakdown

| Component | Responsibility |
|-----------|----------------|
| `IFD_Snapshot_Generator` | Main orchestrator, public API |
| `Html_MGraph` (existing) | Parse HTML into queryable graph |
| `Dependency_Graph_Builder` | Extract and organize dependencies |
| `Snapshot_Writer` | Generate output folder and files |

---

## 3. Pipeline Overview

### 4-Phase Pipeline

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           SNAPSHOT PIPELINE                                 │
└─────────────────────────────────────────────────────────────────────────────┘

Phase 1: PARSE              Phase 2: EXTRACT           Phase 3: BUILD
─────────────────           ────────────────           ──────────────

┌─────────────────┐        ┌─────────────────┐        ┌─────────────────┐
│  HTML File      │        │  Html_MGraph    │        │  Dependency     │
│                 │───────▶│  Document       │───────▶│  Graph          │
│  playground.html│        │                 │        │                 │
└─────────────────┘        │  • head_graph   │        │  • css chains   │
                           │  • body_graph   │        │  • js chains    │
                           │  • scripts_graph│        │  • load order   │
                           └─────────────────┘        └────────┬────────┘
                                                               │
                                                               ▼
Phase 4: GENERATE                                     ┌─────────────────┐
─────────────────                                     │  Manifest       │
                                                      │  + Snapshot     │
┌─────────────────────────────────────────────┐       │  Folder         │
│  v0.2.10-snapshot/                          │◀──────│                 │
│  ├── src/                                   │       └─────────────────┘
│  │   ├── css/                               │
│  │   ├── js/                                │
│  │   └── components/                        │
│  ├── index.html                             │
│  └── manifest.json                          │
└─────────────────────────────────────────────┘
```

### Phase Descriptions

| Phase | Input | Output | Key Operations |
|-------|-------|--------|----------------|
| **1. Parse** | HTML file path | Html_MGraph document | `html__to__html_mgraph()` |
| **2. Extract** | Html_MGraph | Raw dependency list | Query `<link>`, `<script>` elements |
| **3. Build** | Raw dependencies | Organized load chains | Group by logical name, detect base vs surgical |
| **4. Generate** | Load chains + manifest | Snapshot folder | Copy files, transform HTML, write manifest |

---

## 4. Data Structures

### 4.1 Schema Definitions

```python
from typing      import List, Dict, Optional, Literal
from osbot_utils import Type_Safe
from dataclasses import dataclass

# ═══════════════════════════════════════════════════════════════════════════
# Core Type Aliases
# ═══════════════════════════════════════════════════════════════════════════

FileType      = Literal['base', 'surgical']
ResourceType  = Literal['css', 'js']

# ═══════════════════════════════════════════════════════════════════════════
# Schema Classes
# ═══════════════════════════════════════════════════════════════════════════

class Schema__Dependency(Type_Safe):
    """A single file dependency extracted from HTML."""
    
    original_path  : str                    # Path as written in HTML (e.g., "../v0.2.0/css/common.css")
    resolved_path  : str                    # Absolute/normalized path
    source_version : str                    # Extracted version (e.g., "v0.2.0")
    resource_type  : ResourceType           # 'css' or 'js'
    file_type      : FileType               # 'base' or 'surgical'
    logical_name   : str                    # Grouped name (e.g., "css/common", "components/config-panel/config-panel")


class Schema__Load_Chain(Type_Safe):
    """An ordered sequence of files that form a single logical component."""
    
    logical_name : str                      # e.g., "js/services/api-client"
    resource_type: ResourceType             # 'css' or 'js'
    files        : List[Schema__Dependency] # Ordered list (base first, then surgical in version order)


class Schema__Manifest(Type_Safe):
    """Complete snapshot manifest - source of truth for load order."""
    
    snapshot_version    : str               # e.g., "v0.2.10-snapshot"
    source_version      : str               # e.g., "v0.2.10"
    source_entry_point  : str               # e.g., "v0.2.10/playground.html"
    created_at          : str               # ISO 8601 timestamp
    load_chains         : Dict[str, Dict[str, List[Dict]]]  # { 'css': {...}, 'js': {...} }
    file_count          : int               # Total files in snapshot
    source_versions_used: List[str]         # All versions referenced (e.g., ["v0.2.0", "v0.2.3", ...])


class Schema__Snapshot_Config(Type_Safe):
    """Configuration for snapshot generation."""
    
    source_html_path    : str               # Path to entry point HTML
    output_dir          : str               # Where to write snapshot
    base_versions_dir   : str               # Root of version folders (e.g., "/console/v0/v0.2")
    snapshot_suffix     : str  = "-snapshot"# Suffix for snapshot version name
    src_subdir          : str  = "src"      # Subdirectory for source files
    include_tests       : bool = False      # Whether to include .test.js files
    preserve_comments   : bool = True       # Preserve HTML comments in output
```

### 4.2 Manifest JSON Structure

```json
{
  "snapshot": {
    "version": "v0.2.10-snapshot",
    "source_version": "v0.2.10",
    "source_entry_point": "v0.2.10/playground.html",
    "created_at": "2025-01-15T10:30:00Z",
    "file_count": 47,
    "source_versions_used": ["v0.2.0", "v0.2.3", "v0.2.4", "v0.2.5", "v0.2.6", "v0.2.8", "v0.2.9", "v0.2.10"]
  },
  "load_chains": {
    "css": {
      "css/common": [
        {
          "source": "v0.2.0/css/common.css",
          "target": "src/css/common__v0.2.0.css",
          "type": "base",
          "hash": "sha256:abc123..."
        }
      ],
      "css/maximize": [
        {
          "source": "v0.2.4/css/maximize.css",
          "target": "src/css/maximize__v0.2.4.css",
          "type": "base",
          "hash": "sha256:def456..."
        }
      ]
    },
    "js": {
      "js/services/api-client": [
        {
          "source": "v0.2.0/js/services/api-client.js",
          "target": "src/js/services/api-client__v0.2.0.js",
          "type": "base",
          "hash": "sha256:111..."
        },
        {
          "source": "v0.2.3/js/services/api-client.js",
          "target": "src/js/services/api-client__v0.2.3.js",
          "type": "surgical",
          "hash": "sha256:222..."
        },
        {
          "source": "v0.2.5/js/services/api-client.js",
          "target": "src/js/services/api-client__v0.2.5.js",
          "type": "surgical",
          "hash": "sha256:333..."
        },
        {
          "source": "v0.2.9/js/services/api-client.js",
          "target": "src/js/services/api-client__v0.2.9.js",
          "type": "surgical",
          "hash": "sha256:444..."
        }
      ],
      "components/d3-renderer/d3-renderer": [
        {
          "source": "v0.2.0/components/d3-renderer/d3-renderer.js",
          "target": "src/components/d3-renderer/d3-renderer__v0.2.0.js",
          "type": "base",
          "hash": "sha256:555..."
        },
        {
          "source": "v0.2.3/components/d3-renderer/d3-renderer.js",
          "target": "src/components/d3-renderer/d3-renderer__v0.2.3.js",
          "type": "surgical",
          "hash": "sha256:666..."
        },
        {
          "source": "v0.2.8/components/d3-renderer/d3-renderer.js",
          "target": "src/components/d3-renderer/d3-renderer__v0.2.8.js",
          "type": "surgical",
          "hash": "sha256:777..."
        }
      ]
    }
  }
}
```

---

## 5. Component Specifications

### 5.1 IFD_Snapshot_Generator (Main Orchestrator)

```python
class IFD_Snapshot_Generator(Type_Safe):
    """
    Main service for generating IFD snapshots.
    
    Orchestrates the 4-phase pipeline:
    1. Parse HTML entry point with Html_MGraph
    2. Extract CSS/JS dependencies
    3. Build organized load chains
    4. Generate snapshot folder with manifest
    """
    
    config              : Schema__Snapshot_Config
    dependency_builder  : Dependency_Graph_Builder    = None  # Lazy initialized
    snapshot_writer     : Snapshot_Writer             = None  # Lazy initialized
    
    # ═══════════════════════════════════════════════════════════════════════
    # Public API
    # ═══════════════════════════════════════════════════════════════════════
    
    def generate(self) -> Schema__Manifest:
        """
        Main entry point. Executes full pipeline and returns manifest.
        
        Returns:
            Schema__Manifest with complete snapshot metadata
            
        Raises:
            FileNotFoundError: If source HTML doesn't exist
            ValueError: If HTML has no dependencies
            IOError: If unable to write output files
        """
        pass
    
    def generate_manifest_only(self) -> Schema__Manifest:
        """
        Dry run - builds manifest without copying files.
        Useful for validation and debugging.
        """
        pass
    
    def validate_snapshot(self, snapshot_path: str) -> Dict[str, any]:
        """
        Validates an existing snapshot against its manifest.
        
        Returns:
            {
                'valid': bool,
                'missing_files': List[str],
                'hash_mismatches': List[str],
                'extra_files': List[str]
            }
        """
        pass
    
    # ═══════════════════════════════════════════════════════════════════════
    # Pipeline Phases (Internal)
    # ═══════════════════════════════════════════════════════════════════════
    
    def _phase_1_parse(self) -> 'Html_MGraph':
        """Parse HTML file into Html_MGraph structure."""
        pass
    
    def _phase_2_extract(self, html_mgraph: 'Html_MGraph') -> List[Schema__Dependency]:
        """Extract all CSS and JS dependencies from the graph."""
        pass
    
    def _phase_3_build(self, dependencies: List[Schema__Dependency]) -> Dict[str, Schema__Load_Chain]:
        """Organize dependencies into load chains."""
        pass
    
    def _phase_4_generate(self, load_chains: Dict[str, Schema__Load_Chain]) -> Schema__Manifest:
        """Generate snapshot folder and manifest."""
        pass
```

### 5.2 Dependency_Graph_Builder

```python
class Dependency_Graph_Builder(Type_Safe):
    """
    Extracts and organizes dependencies from Html_MGraph.
    
    Responsibilities:
    - Query Html_MGraph for <link> and <script> elements
    - Resolve relative paths to absolute paths
    - Classify files as 'base' or 'surgical'
    - Group files into logical load chains
    - Detect version numbers from paths
    """
    
    base_versions_dir: str   # Root path for resolving version folders
    
    # ═══════════════════════════════════════════════════════════════════════
    # Extraction Methods
    # ═══════════════════════════════════════════════════════════════════════
    
    def extract_css_dependencies(self, html_mgraph: 'Html_MGraph') -> List[Schema__Dependency]:
        """
        Extract all <link rel="stylesheet"> dependencies.
        
        Queries the HEAD graph for link elements, extracts href attributes,
        and creates Schema__Dependency objects.
        
        Example HTML:
            <link rel="stylesheet" href="../v0.2.0/css/common.css">
            <link rel="stylesheet" href="../v0.2.4/css/maximize.css">
        
        Returns:
            List of Schema__Dependency in document order
        """
        pass
    
    def extract_js_dependencies(self, html_mgraph: 'Html_MGraph') -> List[Schema__Dependency]:
        """
        Extract all <script src="..."> dependencies.
        
        Queries the BODY graph for script elements with src attributes
        (skips inline scripts).
        
        Example HTML:
            <script src="../v0.2.0/js/services/api-client.js"></script>
            <script src="../v0.2.3/js/services/api-client.js"></script>
        
        Returns:
            List of Schema__Dependency in document order (critical for load order!)
        """
        pass
    
    # ═══════════════════════════════════════════════════════════════════════
    # Path Resolution
    # ═══════════════════════════════════════════════════════════════════════
    
    def resolve_path(self, base_html_path: str, relative_path: str) -> str:
        """
        Resolve a relative path from HTML to absolute filesystem path.
        
        Example:
            base_html_path: "/console/v0/v0.2/v0.2.10/playground.html"
            relative_path: "../v0.2.0/css/common.css"
            returns: "/console/v0/v0.2/v0.2.0/css/common.css"
        """
        pass
    
    def extract_version(self, path: str) -> str:
        """
        Extract version string from path.
        
        Example:
            path: "/console/v0/v0.2/v0.2.3/js/api-client.js"
            returns: "v0.2.3"
        
        Pattern: Matches vN.N.N or vN.N.NN format
        """
        pass
    
    def extract_logical_name(self, path: str) -> str:
        """
        Extract logical component name from path (without version).
        
        Example:
            path: "/console/v0/v0.2/v0.2.3/components/config-panel/config-panel.js"
            returns: "components/config-panel/config-panel"
            
            path: "/console/v0/v0.2/v0.2.0/css/common.css"
            returns: "css/common"
        """
        pass
    
    # ═══════════════════════════════════════════════════════════════════════
    # Classification
    # ═══════════════════════════════════════════════════════════════════════
    
    def classify_file_type(self, dependencies: List[Schema__Dependency]) -> List[Schema__Dependency]:
        """
        Classify each dependency as 'base' or 'surgical'.
        
        Rules:
        - First file in a load chain (by version) is 'base'
        - Subsequent files with same logical_name are 'surgical'
        
        This requires analyzing all dependencies together to detect chains.
        """
        pass
    
    # ═══════════════════════════════════════════════════════════════════════
    # Chain Building
    # ═══════════════════════════════════════════════════════════════════════
    
    def build_load_chains(self, dependencies: List[Schema__Dependency]) -> Dict[str, Schema__Load_Chain]:
        """
        Group dependencies by logical_name into load chains.
        
        Example input:
            [
                Dependency(logical_name="js/api-client", version="v0.2.0"),
                Dependency(logical_name="components/top-nav", version="v0.2.0"),
                Dependency(logical_name="js/api-client", version="v0.2.3"),
                Dependency(logical_name="js/api-client", version="v0.2.5"),
            ]
        
        Example output:
            {
                "js/api-client": LoadChain(files=[v0.2.0, v0.2.3, v0.2.5]),
                "components/top-nav": LoadChain(files=[v0.2.0])
            }
        
        CRITICAL: Preserve document order within each chain!
        """
        pass
```

### 5.3 Snapshot_Writer

```python
class Snapshot_Writer(Type_Safe):
    """
    Generates the snapshot folder structure.
    
    Responsibilities:
    - Create output directory structure
    - Copy source files with versioned names
    - Transform HTML with new paths
    - Generate manifest.json
    - Compute file hashes for integrity verification
    """
    
    output_dir    : str
    src_subdir    : str = "src"
    
    # ═══════════════════════════════════════════════════════════════════════
    # Directory Operations
    # ═══════════════════════════════════════════════════════════════════════
    
    def create_directory_structure(self, load_chains: Dict[str, Schema__Load_Chain]) -> None:
        """
        Create all necessary subdirectories.
        
        Example output:
            v0.2.10-snapshot/
            ├── src/
            │   ├── css/
            │   ├── js/
            │   │   └── services/
            │   └── components/
            │       ├── top-nav/
            │       ├── config-panel/
            │       └── d3-renderer/
            ├── index.html
            └── manifest.json
        """
        pass
    
    # ═══════════════════════════════════════════════════════════════════════
    # File Operations
    # ═══════════════════════════════════════════════════════════════════════
    
    def copy_files(self, load_chains: Dict[str, Schema__Load_Chain]) -> Dict[str, str]:
        """
        Copy all source files to snapshot with versioned names.
        
        Naming convention: {basename}__{version}.{ext}
        
        Example:
            Source: v0.2.3/js/services/api-client.js
            Target: src/js/services/api-client__v0.2.3.js
        
        Returns:
            Dict mapping source_path -> target_path
        """
        pass
    
    def generate_target_filename(self, dependency: Schema__Dependency) -> str:
        """
        Generate the versioned filename for a dependency.
        
        Pattern: {name}__{version}.{extension}
        
        Examples:
            common.css from v0.2.0 -> common__v0.2.0.css
            api-client.js from v0.2.3 -> api-client__v0.2.3.js
        """
        pass
    
    def compute_file_hash(self, file_path: str) -> str:
        """
        Compute SHA256 hash of file contents.
        
        Used for integrity verification in manifest.
        """
        pass
    
    # ═══════════════════════════════════════════════════════════════════════
    # HTML Transformation
    # ═══════════════════════════════════════════════════════════════════════
    
    def transform_html(self, 
                       original_html_path : str,
                       load_chains        : Dict[str, Schema__Load_Chain],
                       path_mappings      : Dict[str, str]) -> str:
        """
        Transform the HTML file with new local paths.
        
        Original:
            <link rel="stylesheet" href="../v0.2.0/css/common.css">
            <script src="../v0.2.0/js/api-client.js"></script>
            <script src="../v0.2.3/js/api-client.js"></script>
        
        Transformed:
            <link rel="stylesheet" href="src/css/common__v0.2.0.css">
            <script src="src/js/api-client__v0.2.0.js"></script>
            <script src="src/js/api-client__v0.2.3.js"></script>
        
        Also updates:
            - <title> to include snapshot version
            - Version comment at top of file
        """
        pass
    
    # ═══════════════════════════════════════════════════════════════════════
    # Manifest Generation
    # ═══════════════════════════════════════════════════════════════════════
    
    def write_manifest(self, manifest: Schema__Manifest) -> str:
        """
        Write manifest.json to output directory.
        
        Uses json.dumps with indent=2 for readability.
        Python dict order is preserved (3.7+).
        
        Returns:
            Path to written manifest file
        """
        pass
    
    def build_manifest(self,
                       config        : Schema__Snapshot_Config,
                       load_chains   : Dict[str, Schema__Load_Chain],
                       path_mappings : Dict[str, str],
                       file_hashes   : Dict[str, str]) -> Schema__Manifest:
        """
        Build the complete manifest object.
        
        Aggregates:
            - Snapshot metadata (version, timestamp, etc.)
            - All load chains with source/target mappings
            - File hashes for integrity verification
            - List of all source versions used
        """
        pass
```

---

## 6. File Naming Conventions

### 6.1 Versioned File Names

| Original Path | Snapshot Path |
|---------------|---------------|
| `v0.2.0/css/common.css` | `src/css/common__v0.2.0.css` |
| `v0.2.4/css/maximize.css` | `src/css/maximize__v0.2.4.css` |
| `v0.2.0/js/services/api-client.js` | `src/js/services/api-client__v0.2.0.js` |
| `v0.2.3/js/services/api-client.js` | `src/js/services/api-client__v0.2.3.js` |
| `v0.2.0/components/top-nav/top-nav.js` | `src/components/top-nav/top-nav__v0.2.0.js` |

### 6.2 Naming Pattern

```
{basename}__{source_version}.{extension}
```

- **Delimiter**: Double underscore `__` (filesystem-safe, visually distinct)
- **Version format**: Preserved exactly as in source (e.g., `v0.2.10`)
- **Extension**: Preserved from original

### 6.3 Directory Structure

Mirrors the original structure, minus version folders:

```
Original:                              Snapshot:
─────────                              ─────────
v0.2.0/                                src/
├── css/                               ├── css/
│   └── common.css                     │   ├── common__v0.2.0.css
├── js/                                │   └── maximize__v0.2.4.css
│   └── services/                      ├── js/
│       └── api-client.js              │   ├── services/
└── components/                        │   │   ├── api-client__v0.2.0.js
    └── top-nav/                       │   │   └── api-client__v0.2.3.js
        └── top-nav.js                 │   └── playground__v0.2.0.js
                                       └── components/
v0.2.3/                                    └── top-nav/
├── js/                                        └── top-nav__v0.2.0.js
│   └── services/
│       └── api-client.js
...
```

---

## 7. Implementation Details

### 7.1 Html_MGraph Integration

```python
from mgraph_ai_service_html_graph.service.html_graph.Html_Graph__Export__Service import Html_Graph__Export__Service

def parse_html_entry_point(self, html_path: str) -> 'Html_MGraph':
    """
    Parse HTML file using Html_MGraph service.
    
    The Html_MGraph provides:
    - head_graph: Contains <link>, <meta>, <script> in <head>
    - body_graph: Contains DOM structure including <script> at end of body
    - scripts_graph: All script elements
    - styles_graph: All style-related elements
    """
    with open(html_path, 'r', encoding='utf-8') as f:
        html_content = f.read()
    
    service = Html_Graph__Export__Service()
    html_mgraph = service.html__to__html_mgraph(html_content)
    
    return html_mgraph
```

### 7.2 Querying for Dependencies

```python
def extract_css_dependencies(self, html_mgraph: 'Html_MGraph', base_html_path: str) -> List[Schema__Dependency]:
    """
    Query Html_MGraph for CSS dependencies.
    
    Uses MGraph query interface to find all <link> elements with rel="stylesheet".
    """
    dependencies = []
    
    # Query the document for link elements
    # Note: Exact API depends on Html_MGraph implementation
    head_graph = html_mgraph.head_graph()
    
    for node in head_graph.query().by_tag('link'):
        attrs = self._get_node_attributes(node)
        
        if attrs.get('rel') == 'stylesheet' and 'href' in attrs:
            href = attrs['href']
            resolved = self.resolve_path(base_html_path, href)
            version = self.extract_version(resolved)
            logical_name = self.extract_logical_name(resolved)
            
            dependencies.append(Schema__Dependency(
                original_path  = href,
                resolved_path  = resolved,
                source_version = version,
                resource_type  = 'css',
                file_type      = 'base',  # Will be reclassified later
                logical_name   = logical_name
            ))
    
    return dependencies


def extract_js_dependencies(self, html_mgraph: 'Html_MGraph', base_html_path: str) -> List[Schema__Dependency]:
    """
    Query Html_MGraph for JavaScript dependencies.
    
    Searches entire document (HEAD and BODY) for script elements.
    Order is CRITICAL - must preserve document order for correct load sequence.
    """
    dependencies = []
    
    # Scripts can be in both head and body
    # Need to query full document and preserve order
    for node in html_mgraph.query().by_tag('script'):
        attrs = self._get_node_attributes(node)
        
        # Skip inline scripts (no src attribute)
        if 'src' not in attrs:
            continue
        
        src = attrs['src']
        resolved = self.resolve_path(base_html_path, src)
        version = self.extract_version(resolved)
        logical_name = self.extract_logical_name(resolved)
        
        dependencies.append(Schema__Dependency(
            original_path  = src,
            resolved_path  = resolved,
            source_version = version,
            resource_type  = 'js',
            file_type      = 'base',  # Will be reclassified later
            logical_name   = logical_name
        ))
    
    return dependencies
```

### 7.3 Version Extraction

```python
import re

VERSION_PATTERN = re.compile(r'v(\d+)\.(\d+)\.(\d+)')

def extract_version(self, path: str) -> str:
    """
    Extract version string from file path.
    
    Examples:
        "/console/v0/v0.2/v0.2.10/css/common.css" -> "v0.2.10"
        "../v0.2.3/js/api-client.js" -> "v0.2.3"
    """
    match = VERSION_PATTERN.search(path)
    if match:
        return f"v{match.group(1)}.{match.group(2)}.{match.group(3)}"
    raise ValueError(f"No version found in path: {path}")


def extract_logical_name(self, path: str) -> str:
    """
    Extract logical component name (path after version, without extension).
    
    Examples:
        "/console/v0/v0.2/v0.2.3/js/services/api-client.js" 
            -> "js/services/api-client"
        
        "/console/v0/v0.2/v0.2.0/components/config-panel/config-panel.js"
            -> "components/config-panel/config-panel"
    """
    # Find version in path and take everything after it
    match = VERSION_PATTERN.search(path)
    if not match:
        raise ValueError(f"No version found in path: {path}")
    
    # Get the part after the version
    version_end = match.end()
    remainder = path[version_end:].lstrip('/')
    
    # Remove extension
    if '.' in remainder:
        remainder = remainder.rsplit('.', 1)[0]
    
    return remainder
```

### 7.4 Load Chain Classification

```python
def classify_and_build_chains(self, dependencies: List[Schema__Dependency]) -> Dict[str, Schema__Load_Chain]:
    """
    Group dependencies by logical_name and classify as base/surgical.
    
    Rules:
    1. Group by logical_name
    2. Within each group, the file from the EARLIEST version is 'base'
    3. All subsequent versions are 'surgical'
    4. Preserve document order within each group
    """
    # Group by logical_name, preserving order
    chains: Dict[str, List[Schema__Dependency]] = {}
    
    for dep in dependencies:
        if dep.logical_name not in chains:
            chains[dep.logical_name] = []
        chains[dep.logical_name].append(dep)
    
    # Build load chains with classification
    result: Dict[str, Schema__Load_Chain] = {}
    
    for logical_name, deps in chains.items():
        # First file in document order is 'base', rest are 'surgical'
        classified_deps = []
        for i, dep in enumerate(deps):
            dep.file_type = 'base' if i == 0 else 'surgical'
            classified_deps.append(dep)
        
        result[logical_name] = Schema__Load_Chain(
            logical_name  = logical_name,
            resource_type = deps[0].resource_type,
            files         = classified_deps
        )
    
    return result
```

### 7.5 HTML Transformation

```python
from html.parser import HTMLParser
import re

class HTML_Path_Transformer:
    """
    Transform HTML file with new local paths.
    
    Uses regex for simple path replacement while preserving
    document structure, comments, and formatting.
    """
    
    def transform(self, 
                  html_content   : str,
                  path_mappings  : Dict[str, str],
                  snapshot_version: str) -> str:
        """
        Transform HTML content with new paths.
        
        Args:
            html_content: Original HTML string
            path_mappings: Dict of original_path -> new_path
            snapshot_version: Version string for title/comments
            
        Returns:
            Transformed HTML string
        """
        result = html_content
        
        # Replace each path
        for original, new_path in path_mappings.items():
            # Escape special regex characters in original path
            escaped_original = re.escape(original)
            
            # Replace in href="..." and src="..."
            result = re.sub(
                rf'(href|src)="{escaped_original}"',
                rf'\1="{new_path}"',
                result
            )
        
        # Update title if present
        result = re.sub(
            r'<title>([^<]*)</title>',
            f'<title>\\1 ({snapshot_version})</title>',
            result
        )
        
        # Add snapshot comment at top
        snapshot_comment = f'''<!-- ═══════════════════════════════════════════════════════════════════════════
     IFD Snapshot: {snapshot_version}
     Generated: {datetime.now().isoformat()}
     Source: Original entry point with paths transformed to local snapshot
     ═══════════════════════════════════════════════════════════════════════════ -->
'''
        # Insert after DOCTYPE if present, otherwise at start
        if result.strip().upper().startswith('<!DOCTYPE'):
            result = re.sub(
                r'(<!DOCTYPE[^>]*>)\s*',
                rf'\1\n{snapshot_comment}',
                result,
                count=1
            )
        else:
            result = snapshot_comment + result
        
        return result
```

---

## 8. Error Handling

### 8.1 Exception Hierarchy

```python
class IFD_Snapshot_Error(Exception):
    """Base exception for IFD Snapshot Generator."""
    pass


class HTML_Parse_Error(IFD_Snapshot_Error):
    """Failed to parse HTML file."""
    pass


class Dependency_Resolution_Error(IFD_Snapshot_Error):
    """Failed to resolve a dependency path."""
    
    def __init__(self, original_path: str, base_path: str, reason: str):
        self.original_path = original_path
        self.base_path = base_path
        self.reason = reason
        super().__init__(f"Cannot resolve '{original_path}' from '{base_path}': {reason}")


class Missing_Source_File_Error(IFD_Snapshot_Error):
    """Source file referenced in HTML does not exist."""
    
    def __init__(self, path: str):
        self.path = path
        super().__init__(f"Source file not found: {path}")


class Version_Extraction_Error(IFD_Snapshot_Error):
    """Could not extract version from path."""
    
    def __init__(self, path: str):
        self.path = path
        super().__init__(f"No version pattern (vN.N.N) found in path: {path}")


class Snapshot_Write_Error(IFD_Snapshot_Error):
    """Failed to write snapshot files."""
    pass
```

### 8.2 Validation Checks

```python
def validate_config(self) -> List[str]:
    """
    Validate configuration before running pipeline.
    
    Returns:
        List of validation error messages (empty if valid)
    """
    errors = []
    
    # Check source HTML exists
    if not os.path.exists(self.config.source_html_path):
        errors.append(f"Source HTML not found: {self.config.source_html_path}")
    
    # Check base versions directory exists
    if not os.path.isdir(self.config.base_versions_dir):
        errors.append(f"Base versions directory not found: {self.config.base_versions_dir}")
    
    # Check output directory is writable
    output_parent = os.path.dirname(self.config.output_dir)
    if output_parent and not os.access(output_parent, os.W_OK):
        errors.append(f"Cannot write to output directory: {self.config.output_dir}")
    
    return errors


def validate_dependencies(self, dependencies: List[Schema__Dependency]) -> List[str]:
    """
    Validate all dependencies exist on filesystem.
    
    Returns:
        List of missing file paths
    """
    missing = []
    for dep in dependencies:
        if not os.path.exists(dep.resolved_path):
            missing.append(dep.resolved_path)
    return missing
```

---

## 9. Testing Strategy

### 9.1 Unit Tests

```python
class Test__Dependency_Graph_Builder(TestCase):
    """Unit tests for dependency extraction and path resolution."""
    
    def test_extract_version__standard_format(self):
        builder = Dependency_Graph_Builder(base_versions_dir="/console/v0/v0.2")
        
        assert builder.extract_version("/console/v0/v0.2/v0.2.10/css/common.css") == "v0.2.10"
        assert builder.extract_version("../v0.2.3/js/api-client.js") == "v0.2.3"
        assert builder.extract_version("v0.2.0/components/nav/nav.js") == "v0.2.0"
    
    def test_extract_version__double_digit_patch(self):
        builder = Dependency_Graph_Builder(base_versions_dir="/console/v0/v0.2")
        
        assert builder.extract_version("v0.2.15/js/app.js") == "v0.2.15"
    
    def test_extract_logical_name__js_service(self):
        builder = Dependency_Graph_Builder(base_versions_dir="/console/v0/v0.2")
        
        path = "/console/v0/v0.2/v0.2.3/js/services/api-client.js"
        assert builder.extract_logical_name(path) == "js/services/api-client"
    
    def test_extract_logical_name__component(self):
        builder = Dependency_Graph_Builder(base_versions_dir="/console/v0/v0.2")
        
        path = "/console/v0/v0.2/v0.2.0/components/config-panel/config-panel.js"
        assert builder.extract_logical_name(path) == "components/config-panel/config-panel"
    
    def test_classify_file_types__single_file_is_base(self):
        builder = Dependency_Graph_Builder(base_versions_dir="/console/v0/v0.2")
        
        deps = [
            Schema__Dependency(
                original_path="../v0.2.0/css/common.css",
                resolved_path="/console/v0/v0.2/v0.2.0/css/common.css",
                source_version="v0.2.0",
                resource_type="css",
                file_type="base",
                logical_name="css/common"
            )
        ]
        
        chains = builder.classify_and_build_chains(deps)
        
        assert len(chains) == 1
        assert chains["css/common"].files[0].file_type == "base"
    
    def test_classify_file_types__chain_has_base_then_surgical(self):
        builder = Dependency_Graph_Builder(base_versions_dir="/console/v0/v0.2")
        
        deps = [
            Schema__Dependency(logical_name="js/api", source_version="v0.2.0", ...),
            Schema__Dependency(logical_name="js/api", source_version="v0.2.3", ...),
            Schema__Dependency(logical_name="js/api", source_version="v0.2.5", ...),
        ]
        
        chains = builder.classify_and_build_chains(deps)
        
        assert chains["js/api"].files[0].file_type == "base"
        assert chains["js/api"].files[1].file_type == "surgical"
        assert chains["js/api"].files[2].file_type == "surgical"
```

### 9.2 Integration Tests

```python
class Test__IFD_Snapshot_Generator__Integration(TestCase):
    """Integration tests with real HTML files."""
    
    @classmethod
    def setUpClass(cls):
        """Create test fixture with sample IFD structure."""
        cls.test_dir = create_temp_ifd_structure()
    
    def test_generate__creates_complete_snapshot(self):
        config = Schema__Snapshot_Config(
            source_html_path = f"{self.test_dir}/v0.2.10/playground.html",
            output_dir       = f"{self.test_dir}/v0.2.10-snapshot",
            base_versions_dir= self.test_dir
        )
        
        generator = IFD_Snapshot_Generator(config=config)
        manifest = generator.generate()
        
        # Verify manifest
        assert manifest.snapshot_version == "v0.2.10-snapshot"
        assert manifest.file_count > 0
        
        # Verify files exist
        for chain_name, chain_data in manifest.load_chains['js'].items():
            for file_info in chain_data:
                target_path = os.path.join(config.output_dir, file_info['target'])
                assert os.path.exists(target_path), f"Missing: {target_path}"
    
    def test_generate__preserves_load_order(self):
        """Critical: Load order must match original HTML."""
        config = Schema__Snapshot_Config(...)
        generator = IFD_Snapshot_Generator(config=config)
        manifest = generator.generate()
        
        # Read generated HTML
        with open(f"{config.output_dir}/index.html") as f:
            html = f.read()
        
        # Extract script order from HTML
        script_order = re.findall(r'<script src="([^"]+)"', html)
        
        # Verify order matches manifest
        expected_order = []
        for chain in manifest.load_chains['js'].values():
            for file_info in chain:
                expected_order.append(file_info['target'])
        
        assert script_order == expected_order
    
    def test_validate_snapshot__detects_missing_files(self):
        """Validation should catch missing files."""
        # Create snapshot
        generator = IFD_Snapshot_Generator(config=config)
        generator.generate()
        
        # Delete a file
        os.remove(f"{config.output_dir}/src/css/common__v0.2.0.css")
        
        # Validate should fail
        result = generator.validate_snapshot(config.output_dir)
        
        assert result['valid'] == False
        assert "src/css/common__v0.2.0.css" in result['missing_files']
```

### 9.3 Round-Trip Test

```python
def test_snapshot__is_functionally_equivalent(self):
    """
    The snapshot should produce identical runtime behavior.
    
    This is the ultimate validation: run the original and snapshot
    versions and verify they behave identically.
    """
    # Generate snapshot
    generator = IFD_Snapshot_Generator(config=config)
    generator.generate()
    
    # Both should load without errors (would need browser testing)
    # For now, verify all files are valid JS/CSS
    
    snapshot_dir = config.output_dir
    for root, dirs, files in os.walk(os.path.join(snapshot_dir, 'src')):
        for file in files:
            path = os.path.join(root, file)
            if file.endswith('.js'):
                # Verify JS is syntactically valid
                with open(path) as f:
                    content = f.read()
                # Could use esprima or similar to validate
                assert not content.startswith('<!DOCTYPE'), f"HTML in JS file: {path}"
            elif file.endswith('.css'):
                # Verify CSS is syntactically valid
                with open(path) as f:
                    content = f.read()
                assert not content.startswith('<!DOCTYPE'), f"HTML in CSS file: {path}"
```

---

## 10. Usage Examples

### 10.1 Basic Usage

```python
from ifd_snapshot_generator import IFD_Snapshot_Generator, Schema__Snapshot_Config

# Configure
config = Schema__Snapshot_Config(
    source_html_path  = "/console/v0/v0.2/v0.2.10/playground.html",
    output_dir        = "/console/v0/v0.2/v0.2.10-snapshot",
    base_versions_dir = "/console/v0/v0.2"
)

# Generate snapshot
generator = IFD_Snapshot_Generator(config=config)
manifest = generator.generate()

print(f"Created snapshot: {manifest.snapshot_version}")
print(f"Files copied: {manifest.file_count}")
print(f"Versions used: {manifest.source_versions_used}")
```

### 10.2 Dry Run (Manifest Only)

```python
# Generate manifest without copying files
manifest = generator.generate_manifest_only()

# Inspect what would be created
for chain_name, files in manifest.load_chains['js'].items():
    print(f"\n{chain_name}:")
    for f in files:
        print(f"  [{f['type']}] {f['source']} -> {f['target']}")
```

### 10.3 Validation

```python
# Validate existing snapshot
result = generator.validate_snapshot("/console/v0/v0.2/v0.2.10-snapshot")

if result['valid']:
    print("✓ Snapshot is valid")
else:
    print("✗ Snapshot has issues:")
    for missing in result['missing_files']:
        print(f"  Missing: {missing}")
    for mismatch in result['hash_mismatches']:
        print(f"  Hash mismatch: {mismatch}")
```

### 10.4 CLI Usage

```bash
# Generate snapshot
python -m ifd_snapshot_generator generate \
    --source /console/v0/v0.2/v0.2.10/playground.html \
    --output /console/v0/v0.2/v0.2.10-snapshot \
    --base-dir /console/v0/v0.2

# Dry run
python -m ifd_snapshot_generator generate \
    --source /console/v0/v0.2/v0.2.10/playground.html \
    --dry-run

# Validate
python -m ifd_snapshot_generator validate \
    --snapshot /console/v0/v0.2/v0.2.10-snapshot
```

---

## 11. API Reference

### 11.1 IFD_Snapshot_Generator

| Method | Parameters | Returns | Description |
|--------|------------|---------|-------------|
| `generate()` | - | `Schema__Manifest` | Full pipeline: parse, extract, build, write |
| `generate_manifest_only()` | - | `Schema__Manifest` | Dry run without file operations |
| `validate_snapshot(path)` | `str` | `Dict` | Validate snapshot against manifest |

### 11.2 Dependency_Graph_Builder

| Method | Parameters | Returns | Description |
|--------|------------|---------|-------------|
| `extract_css_dependencies(mgraph, base_path)` | `Html_MGraph`, `str` | `List[Dependency]` | Extract CSS from HTML |
| `extract_js_dependencies(mgraph, base_path)` | `Html_MGraph`, `str` | `List[Dependency]` | Extract JS from HTML |
| `resolve_path(base, relative)` | `str`, `str` | `str` | Resolve relative to absolute path |
| `extract_version(path)` | `str` | `str` | Extract vN.N.N from path |
| `extract_logical_name(path)` | `str` | `str` | Extract component name |
| `classify_and_build_chains(deps)` | `List[Dependency]` | `Dict[str, LoadChain]` | Build load chains |

### 11.3 Snapshot_Writer

| Method | Parameters | Returns | Description |
|--------|------------|---------|-------------|
| `create_directory_structure(chains)` | `Dict[str, LoadChain]` | `None` | Create folder structure |
| `copy_files(chains)` | `Dict[str, LoadChain]` | `Dict[str, str]` | Copy with versioned names |
| `transform_html(html_path, chains, mappings)` | `str`, `Dict`, `Dict` | `str` | Transform HTML paths |
| `write_manifest(manifest)` | `Schema__Manifest` | `str` | Write manifest.json |
| `compute_file_hash(path)` | `str` | `str` | SHA256 hash of file |

---

## Summary

The IFD Snapshot Generator provides:

1. **Deterministic Output**: Same input always produces identical snapshot
2. **Zero LLM Involvement**: Pure programmatic transformation
3. **Complete Dependency Resolution**: All files needed to run the version
4. **Preserved Load Order**: Manifest is source of truth for script/CSS order
5. **Audit Trail**: Full provenance in manifest.json
6. **Self-Contained**: Snapshot runs with zero external dependencies
7. **Verifiable**: Hash-based integrity checking

**This enables the IFD consolidation workflow**:
```
v1.1.x (scattered) → Snapshot Generator → v1.1.x-snapshot (clean) → LLM merge → v1.2.0
```

The snapshot reduces LLM context significantly and provides clear file provenance, making the consolidation step reliable and trustworthy.

---

*This is the IFD Snapshot Generator. Programmatic, deterministic, and built for reliable consolidation.*
